<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C/C++随笔 | Papillon's electroic brain</title><meta name="author" content="Papillon"><meta name="copyright" content="Papillon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C文件操作文件的打开fopen()：打开文件文件的关闭fclose()：关闭文件 文件的读写fgetc()：读取一个字符   int fgetc ( FILE * stream );fputc()：写入一个字符   int fputc( int c, FILE *stream ); fgets()：读取一个字符串 char * fgets ( char * str, int num, FILE *">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++随笔">
<meta property="og:url" content="https://ruomio.github.io/2024/02/19/CC++/index.html">
<meta property="og:site_name" content="Papillon&#39;s electroic brain">
<meta property="og:description" content="C文件操作文件的打开fopen()：打开文件文件的关闭fclose()：关闭文件 文件的读写fgetc()：读取一个字符   int fgetc ( FILE * stream );fputc()：写入一个字符   int fputc( int c, FILE *stream ); fgets()：读取一个字符串 char * fgets ( char * str, int num, FILE *">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ruomio.github.io/img/image1.png">
<meta property="article:published_time" content="2024-02-19T07:16:50.000Z">
<meta property="article:modified_time" content="2024-02-26T07:11:02.512Z">
<meta property="article:author" content="Papillon">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ruomio.github.io/img/image1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ruomio.github.io/2024/02/19/CC++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C/C++随笔',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-26 15:11:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/image1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/red_ball.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Papillon's electroic brain"><span class="site-name">Papillon's electroic brain</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C/C++随笔</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-19T07:16:50.000Z" title="发表于 2024-02-19 15:16:50">2024-02-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-26T07:11:02.512Z" title="更新于 2024-02-26 15:11:02">2024-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/">C/C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C/C++随笔"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件的打开<br>fopen()：打开文件<br>文件的关闭<br>fclose()：关闭文件</p>
<p>文件的读写<br>fgetc()：读取一个字符   int fgetc ( FILE * stream );<br>fputc()：写入一个字符   int fputc( int c, FILE *stream );</p>
<p>fgets()：读取一个字符串 char * fgets ( char * str, int num, FILE * stream );<br>fputs()：写入一个字符串 int fputs( const char *string, FILE *stream );</p>
<p>fprintf()：写入格式化数据<br>fscanf()：格式化读取数据</p>
<p>fread()：读取数据   size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );<br>fwrite()：写入数据  size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );</p>
<p>文件状态检查<br>feof()：文件是否结束<br>ferror()：文件读&#x2F;写是否出错<br>clearerr()：清除文件错误标志<br>ftell()：文件指针的当前位置</p>
<p>文件指针定位<br>rewind()：把文件指针移到开始处<br>fseek()：重定位文件指针</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>数组指针 !&#x3D; 指针数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [] 优先级比 * 高</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **p = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">3</span>]</span><br><span class="line">    <span class="comment">//传参数</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">matrix_mutifly</span>(<span class="built_in">int</span> (*A)[<span class="number">10</span>], <span class="built_in">int</span> (*B)[<span class="number">10</span>], <span class="built_in">int</span> (*C)[<span class="number">10</span>])&#123;&#125;</span><br></pre></td></tr></table></figure>


<h1 id="函数指针与回调函数"><a href="#函数指针与回调函数" class="headerlink" title="函数指针与回调函数"></a>函数指针与回调函数</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="comment">// 函数指针初始化</span></span><br><span class="line"><span class="type">int</span> (*p_func)(<span class="type">int</span>) = func;</span><br><span class="line"><span class="comment">// 函数指针调用</span></span><br><span class="line">p_func(<span class="number">5</span>);              </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="type">int</span> (* p)(<span class="type">int</span>, <span class="type">int</span>) = &amp; max; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是: %d\n&quot;</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回调函数-Callback-Function"><a href="#回调函数-Callback-Function" class="headerlink" title="回调函数 Callback Function"></a>回调函数 Callback Function</h2><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<p>回调函数通常是在特定的事件或条件发生时，由另外的一方调用的，用于对该事件或条件进行响应。其意义就在于解耦。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rfun_call</span><span class="params">(<span class="type">int</span> (*pfun)(<span class="type">unsigned</span>), <span class="type">unsigned</span> x)</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">return</span> pfun(x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">populate_array</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">size_t</span> arraySize, <span class="type">int</span> (*getNextValue)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNextRandomValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myarray[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">/* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span></span><br><span class="line">    populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><pre><code>fd_set 使用数组实现
1.fd_size 有限制 1024 bitmap
        fd【i】 = accept()
    2.fdset不可重用，新的fd进来，重新创建
    3.用户态和内核态拷贝产生开销
    4.O(n)时间复杂度的轮询
    成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0
    具有超时时间
</code></pre>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><pre><code>基于结构体存储fd
struct pollfd&#123;
    int fd;
    short events;
    short revents; //可重用
&#125;
解决了select的1,2两点缺点
</code></pre>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><pre><code>解决select的1，2，3，4
不需要轮询，时间复杂度为O(1)
epoll_create  创建一个白板 存放fd_events
epoll_ctl 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上
epoll_wait 通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符

两种触发模式：
    LT:水平触发
        当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。
    ET:边缘触发
        和 LT 模式不同的是，通知之后进程必须立即处理事件。
        下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，
        因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
</code></pre>
<h2 id="动态静态链接库"><a href="#动态静态链接库" class="headerlink" title="动态静态链接库"></a>动态静态链接库</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>静态库(.a): 在链接期间被应用程序直接链接进可执行文件</p>
</li>
<li><p>动态链接库(.so): 动态库还分为两种用法:<br>  a) 应用程序运行期间链接动态库，但是在编译期间声明动态库的存在，也就是说这种动态库必须在编译时对编译器可见，但编译器却不将此种库编译进可执行文件;</p>
<p>  b) 在运行期间，动态加载和卸载的库，使用动态加载方法加载。这种库的形式跟动态链接没有本质区别，区别是在调用时，是由用户程序决定何时链接的，而不是由系统链接器自动链接</p>
</li>
</ul>
<h2 id="编译库"><a href="#编译库" class="headerlink" title="编译库"></a>编译库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">动态库</span></span><br><span class="line">gcc -shared -fPIC xxx.c -o libxxx.so</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">静态库</span></span><br><span class="line">gcc -c xx.c -o xx.o  //生成math.o</span><br><span class="line">ar rc xx.a xx.o  //生成math.a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libxxx.a</span></span><br><span class="line">g++  main.c -L. -lxxx -o main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libxxx.so</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</span><br><span class="line">g++ -o main main.c -I. -L. -lxxx -stacic</span><br></pre></td></tr></table></figure>


<p>引入对应的头文件即可使用（相当于.a, .so 隐藏了具体实现）</p>
<p><strong>动态库使用方法</strong><br>    动态链接库的使用需要库的开发者提供生成的.lib文件和.dll文件。或者只提供dll文件。使用时只能使用dll中导出的函数，未导出的函数只能在dll内部使用。</p>
<pre><code>Dll的调用有显示连接和隐式连接两种：隐式连接需要三个东西，分别是*.h头文件，lib库（动态的）， DLL库；显示连接只需要.dll文件即可。
</code></pre>
<h4 id="显式-动态-加载"><a href="#显式-动态-加载" class="headerlink" title="显式(动态)加载"></a>显式(动态)加载</h4><p>这种方式通过调用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=API%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">API函数</a>来完成对DLL的加载与卸载，能更加有效地使用内存，在编写大型应用程序时往往采用此方式。</p>
<p><strong>显式加载优点</strong></p>
<ul>
<li>灵活，可以在需要的时候用<code>LoadLibrary</code>进行加载，在不需要的时候用<code>FreeLibrary</code>进行卸载，这样可以不必占用内存。</li>
<li>可以在没有dll时候发现，而不致程序报错。</li>
<li>加载程序中有条件才运行的库。</li>
<li>热更新，在不停止程序的前提下进行更新。</li>
</ul>
<p><strong>显式加载缺点</strong></p>
<ul>
<li>复杂一些，需要显示获得函数地址。</li>
<li><code>dll</code>没有对应的<code>lib</code>文件，此时只能进行动态加载。</li>
</ul>
<p><strong>加载方法</strong></p>
<ul>
<li>使用Windows API函数Load Library将<code>DLL</code>模块映像到进程的内存空间，对<code>DLL</code>模块进行动态加载。</li>
<li>使用<code>GetProcAddress</code>函数得到要调用<code>DLL</code>中的函数的指针。</li>
<li>不用<code>DLL</code>时，用<code>FreeLibrary</code>函数或者<code>AfxFreeLibrary</code>函数从进程的地址空间显式卸载<code>DLL</code>。</li>
</ul>
<ol>
<li>动态(显式)调用，只需要<code>xxx.dll</code><br><strong>Windoiws环境</strong>：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DynamicUse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 运行时加载DLL库,静态加载</span></span><br><span class="line">	HMODULE <span class="keyword">module</span> = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;DLLTest1.dll&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;加载DLLTest1.dll动态库失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*AddFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 定义函数指针类型</span></span><br><span class="line">	AddFunc add; </span><br><span class="line">    <span class="comment">// 导出函数地址</span></span><br><span class="line">	add = (AddFunc)<span class="built_in">GetProcAddress</span>(<span class="keyword">module</span>, <span class="string">&quot;add&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sum  = <span class="built_in">add</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;动态调用，sum = %d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><code>linux</code>环境</strong>: Linux中的<code>so</code>库<strong>实现库的动态加载。最终链接时，使用</strong><code>-ldl</code>**。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">dlerror</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlsym</span><span class="params">(<span class="type">void</span> *handle,<span class="type">const</span> <span class="type">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span></span>;</span><br><span class="line"> </span><br><span class="line">Link with -ldl</span><br></pre></td></tr></table></figure>
<p><strong>编译链接</strong><br><code>gcc dmain.c -ldl -o main</code></p>
<ol start="2">
<li>静态(隐式)调用,还需要<code>xxx.h</code><br><strong>windows环境</strong>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 先将lib与dll导入项目</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;DLLTest1.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态调用DLL库</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StaticUse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;静态调用，sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><code>linux</code>环境</strong>:<br>设置<code>LD_LIBRARY_PATH</code> 参数指定路径，否则无法运行可执行程序<br><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</code> &#x2F;&#x2F; .表示当前目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -L./ -lmath -o main</span><br></pre></td></tr></table></figure>


<h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><h3 id="nm命令"><a href="#nm命令" class="headerlink" title="nm命令"></a>nm命令</h3><p>有时候可能需要查看一个库中到底有哪些函数，<strong>nm****命令</strong>可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：</p>
<p>-  一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；</p>
<p>-  一种是库中定义的函数，用T表示，这是最常见的；</p>
<p>-  一种是所谓的弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。</p>
<p><code>$nm libhello.a</code></p>
<h3 id="ldd命令"><a href="#ldd命令" class="headerlink" title="ldd命令"></a>ldd命令</h3><p><strong>ldd****命令可以查看一个可执行程序依赖的共享库</strong>，例如我们编写的四则运算动态库依赖下面这些库：</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">单例模式：确保一个类只有一个实例，并提供全局访问点。</span><br><span class="line">工厂模式：通过工厂方法创建对象，而无需直接使用 new 关键字。</span><br><span class="line">抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</span><br><span class="line">代理模式：为其他对象提供一种代理以控制对这个对象的访问。</span><br><span class="line">观察者模式：定义对象间的一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知。</span><br><span class="line">装饰器模式：动态地给一个对象增加一些额外的职责，就像给一个人穿上不同的衣服一样可以改变他的外表。</span><br><span class="line">模板方法模式：定义一个操作中算法的骨架，将一些步骤延迟到子类中去实现。</span><br><span class="line">策略模式：定义了一系列的算法，并将每个算法封装起来，使它们可以相互替换。</span><br><span class="line">迭代器模式：提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</span><br><span class="line">适配器模式：将一个类的接口转换成客户希望的另外一个接口。</span><br></pre></td></tr></table></figure>

<h2 id="PIMPL"><a href="#PIMPL" class="headerlink" title="PIMPL"></a>PIMPL</h2><blockquote>
<p>PIMPL（Pointer to Implementation）是一种设计模式，用于减少类之间的依赖关系和编译时间。它的基本思想是将类的实现细节封装在一个独立的类中，然后将这个类的指针作为类的成员变量来使用，从而达到降低编译时耦合度的目的。</p>
</blockquote>
<blockquote>
<p>具体来说，PIMPL 模式将公共接口与私有实现分离开来。公共接口是一个完整的类定义，而私有实现则是由一个独立的类进行实现，这个独立的类被称为 PIMPL 类。PIMPL 类只能在类的实现文件中引用，在类的头文件中并不可见。这样做可以有效地隐藏内部实现细节，并且在修改实现时不会影响用户代码的编译。</p>
</blockquote>
<blockquote>
<p>使用 PIMPL 模式可以避免头文件的相互包含，从而减少编译时间。此外，当需要修改类的实现时，只需要修改 PIMPL 类的定义，而不需要重新编译使用这个类的客户端代码。这使得代码的维护更加容易，也提高了代码的可重用性。</p>
</blockquote>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[&quot;socket() &lt;br&gt; 1. 创建流式socket&quot;] --&gt; B[&quot;connnect() &lt;br&gt; 2. 向服务器发起连接请求&quot;]</span><br><span class="line"> B --&gt; C[&quot;send()/recv() &lt;br&gt; 3. 发送/接收数据&quot;]</span><br><span class="line"> C --&gt; D[&quot;close() &lt;br&gt; 4. 关闭socket连接，释放资源&quot;]</span><br><span class="line"> M[客户端]</span><br></pre></td></tr></table></figure>

<p>服务器端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[&quot;socket() &lt;br&gt; 1. 创建流式socket&quot;] --&gt; B[&quot;bind() &lt;br&gt; 2. 指定用于通讯的ip地址和端口&quot;]</span><br><span class="line">B --&gt; C[&quot;listen() &lt;br&gt; 3. 把socket设置为监听模式&quot;]</span><br><span class="line">C --&gt; D[&quot;accept() &lt;br&gt; 4. 接受客户端的连接&quot;]</span><br><span class="line">D --&gt; E[&quot;recv()/send() &lt;br&gt; 5. 接收/发送数据&quot;]</span><br><span class="line">E --&gt; F[&quot;close() &lt;br&gt; 6. 关闭socket连接，释放资源&quot;]</span><br></pre></td></tr></table></figure>





















<h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><p>C++ 是一种面向对象的编程语言，它具有以下特性：</p>
<ol>
<li>面向对象：C++ 支持面向对象的编程范式，包括封装、继承和多态。</li>
<li>泛型编程：C++ 支持泛型编程，可以使用模板来实现通用的数据类型和算法。</li>
<li>高效性：C++ 是一种高效的语言，它可以直接操作内存，而不需要通过虚拟机或解释器来执行代码。</li>
<li>多重继承：C++ 支持多重继承，可以从多个基类中继承属性和方法。</li>
<li>强类型：C++ 是一种强类型语言，可以在编译时检查类型错误。</li>
<li>高级内存管理：C++ 允许程序员直接管理内存，包括动态分配和释放内存。</li>
<li>运算符重载：C++ 允许程序员重载运算符，可以自定义对象之间的运算。</li>
<li>内联函数：C++ 支持内联函数，可以将函数的代码直接插入到调用它的地方，提高执行效率。</li>
<li>异常处理：C++ 支持异常处理，可以在程序出现异常时进行处理。</li>
<li>标准库：C++ 标准库提供了丰富的函数和类，包括容器、算法、输入输出和字符串处理等。</li>
</ol>
<h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><h3 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h3><p><code>x++</code> 是右值；<code>++x</code> 是左值。<br>笼统区分左右值是看在等号左边还是右边。但凡能取地址就是左值；通常字面量是一个右值，字符串字面量除外（<code>auto p = &amp;&quot;hello&quot;;</code>,其能取地址）； </p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p><code>int a = 0; int &amp;b = a;</code></p>
<ol>
<li>常量左值引用既可以接收左值又可以接收右值。但无法修改内容，强制类型转换除外。</li>
<li></li>
</ol>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p><code>int &amp;&amp;x = 1;</code><br>作用: 延长右值的声明周期，减少对象的复制，提升程序性能。</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>移动构造器，只有指针的替换，没有内存的申请和释放。形参要使用右值引用，因为资源被转移而不会发生深拷贝。<br>移动构造器要加<code>noexcept</code>保证函数发生异常时终止，因为移动时发生异常会造成源对象与目标对象都不完整的情况。</p>
<h3 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[expression表达式 ] --&gt; B[glvalue泛左值]</span><br><span class="line">A --&gt; C[rvalue右值]</span><br><span class="line">B --&gt; D[lvalue左值]</span><br><span class="line">B --&gt; E[xvalue将亡值]</span><br><span class="line">C --&gt; E</span><br><span class="line">C --&gt; F[prvalue纯右值]</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>需要引入相应的头文件<br>1 vector<code>&lt;int&gt;</code>vec;&#x2F;&#x2F;定义vector,常用<br>2 list<code>&lt;int&gt;</code>lis;<br>3 deque<code>&lt;int&gt;</code>deq;<br>4 stack<code>&lt;int&gt;</code>sta;&#x2F;&#x2F;定义栈,常用<br>5 queue<code>&lt;int&gt;</code>que;&#x2F;&#x2F;定义栈,常用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector的定义</span></span><br><span class="line">vector                   创建一个空的vector。</span><br><span class="line"><span class="function">vector  <span class="title">c1</span><span class="params">(c2)</span>           复制一个vector</span></span><br><span class="line"><span class="function">vector  <span class="title">c</span><span class="params">(n)</span>             创建一个vector，含有n个数据，数据均已缺省构造产生</span></span><br><span class="line"><span class="function">vector  <span class="title">c</span><span class="params">(n, elem)</span>   　　 创建一个含有n个elem拷贝的vector</span></span><br><span class="line"><span class="function">vector  <span class="title">c</span><span class="params">(beg,end)</span>       创建一个含有n个elem拷贝的vector</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//vector的操作</span></span></span><br><span class="line"><span class="function">c.<span class="title">assign</span><span class="params">(beg,end)</span>        将 [beg</span>; end)区间中的数据赋值给c。</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem)　　　　  将n个elem的拷贝赋值给c。</span><br><span class="line">c.<span class="built_in">at</span>(idx)　　　　　　　　  传回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">c.<span class="built_in">back</span>()                 传回最后一个数据，不检查这个数据是否存在。</span><br><span class="line">c.<span class="built_in">begin</span>()    　　　　　　　传回迭代器中的第一个数据地址。</span><br><span class="line">c.<span class="built_in">capacity</span>()  　　　　　　 返回容器中数据个数。</span><br><span class="line">c.<span class="built_in">clear</span>()     　　　　　　 移除容器中所有数据。</span><br><span class="line">c.<span class="built_in">empty</span>()     　　　　　　 判断容器是否为空。</span><br><span class="line">c.<span class="built_in">end</span>()       　　　　　　 指向迭代器中末端元素的下一个，指向一个不存在元素。</span><br><span class="line">c.<span class="built_in">erase</span>(pos) 　　　　　　  删除pos位置的数据，传回下一个数据的位置。</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end)  　　 　 删除[beg,end)区间的数据，传回下一个数据的位置。</span><br><span class="line">c.<span class="built_in">front</span>()     　　　　　　 传回第一个数据。</span><br><span class="line">get_allocator　　　　　　  使用构造函数返回一个拷贝。</span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem)   　　 在pos位置插入一个elem拷贝，传回新数据位置。</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem)  　　在pos位置插入n个elem数据。无返回值。</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end) 　　在pos位置插入在[beg,end)区间的数据。无返回值。</span><br><span class="line">c.<span class="built_in">max_size</span>()       　　   返回容器中最大数据的数量。</span><br><span class="line">c.<span class="built_in">pop_back</span>()      　　　　 删除最后一个数据。</span><br><span class="line">c.<span class="built_in">push_back</span>(elem) 　　    在尾部加入一个数据。</span><br><span class="line">c.<span class="built_in">rbegin</span>()         　　　　传回一个逆向队列的第一个数据。</span><br><span class="line">c.<span class="built_in">rend</span>()           　　　　传回一个逆向队列的最后一个数据的下一个位置。</span><br><span class="line">c.<span class="built_in">resize</span>(num)     　　　　 重新指定队列的长度。</span><br><span class="line">c.<span class="built_in">reserve</span>()       　　　　 保留适当的容量。</span><br><span class="line">c.<span class="built_in">size</span>()             　　 返回容器中实际数据的个数。</span><br><span class="line">c1.<span class="built_in">swap</span>(c2)</span><br><span class="line"><span class="built_in">swap</span>(c1,c2)      　　　　　将c1和c2元素互换。同上操作。</span><br><span class="line"><span class="keyword">operator</span>[]       　　　　　返回容器中指定位置的一个引用。</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="inline-与-static"><a href="#inline-与-static" class="headerlink" title="inline 与 static"></a>inline 与 static</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">非类的成员函数以及成员变量</span><br><span class="line">inline修饰的函数或变量（c++17开始可以修饰变量）在全局保留一份；</span><br><span class="line"></span><br><span class="line">static修饰的函数或者变量会在各自的编译单元都保留一份；</span><br><span class="line"></span><br><span class="line">static函数的局部static变量也会有多份，inline函数的static变量只有一份;</span><br><span class="line"></span><br><span class="line">static inline 修饰的函数或者变量与static单独修饰的效果一致；</span><br><span class="line"></span><br><span class="line">inline 不能修饰局部变量；</span><br><span class="line"></span><br><span class="line">有关类的成员函数以及成员变量</span><br><span class="line">类的非const静态成员变量初始化，C++ 17可以通过static inline 在类内直接初始化，C++17之前必须在类外初始化（const static 修饰的变量也可以类内初始化，这个在之前也是可以的）；</span><br><span class="line"></span><br><span class="line">C++17之后，类的静态成员变量在类内通过static声明，在类外（但是在头文件中）初始化不加inline的话可能会导致重定义从而出现链接错误，而加了inline 就不会出错，类似有无inline修饰的全局函数；</span><br><span class="line"></span><br><span class="line">C++ 17之前必须在.cpp中初始化静态成员才不会出现重定义的错误，在.h中初始化还是会导致重定义错误，因为C++17之前的标准不支持inline修饰类的静态成员变量；</span><br><span class="line"></span><br><span class="line">类中的函数其实可以认为是都隐式加了inline的，因为类中的所有函数在全局都只有一份，而有无static修饰只是限制该函数对类数据成员的使用（类的static函数只能使用static成员变量，类的普通成员函数可以使用所有的成员变量 ）；</span><br><span class="line"></span><br><span class="line"> inline使用场景：(1)、可以使用inline函数完全取代表达式形式的宏定义；(2)、内联函数一般只会用在函数内容非常简单的时候，这是因为，内联函数的代码会在任何调用它的地方展开，如果函数太复杂，代码膨胀带来的恶果很可能会大于效率的提高带来的益处。</span><br><span class="line"> </span><br><span class="line"> 内联函数可减少cpu的系统开销，并且程序的整体速度将加快，但当内联函数很大时，会有相反的作用，因此一般比较小的函数才使用内联函数．</span><br><span class="line"> </span><br><span class="line">  内联是一种对编译器的请求，下面这些情况会阻止编译器服从这项请求：如果函数中包含有循环，switch或goto语句，递归函数，含有static的函数．</span><br><span class="line">  </span><br><span class="line">   static inline，静态内联函数，它不使用函数调用，直接将汇编代码插入在调用该函数处。</span><br><span class="line">   static inline，可以把它认为是一个static的函数，加上了inline的属性。static inline函数和static函数一样，其定义的范围是local的，即可以在程序内有多个不同的定义(只要不位于同一个文件内即可)。</span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、纯虚函数声明如下： <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、虚函数声明如下：<span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameter)</span> 虚函数必须实现，如果不实现，编译器将报错.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5、虚函数是C++中用于实现多态<span class="params">(polymorphism)</span>的机制。核心理念就是通过基类访问派生类定义的函数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</span></span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture-list] (parameter-list) -&gt; <span class="keyword">return</span>-type &#123; function-body &#125;</span><br><span class="line">[] &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式的函数体</span></span><br><span class="line">    <span class="comment">// 无参数，无返回值</span></span><br><span class="line">&#125;</span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式的函数体</span></span><br><span class="line">    <span class="comment">// 参数为 a 和 b，无返回值</span></span><br><span class="line">&#125;</span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式的函数体</span></span><br><span class="line">    <span class="comment">// 参数为 a 和 b，返回值为 int 类型</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">[]中为空表示不捕获外部变量</span><br><span class="line">[=] 按值捕获所有外部变量</span><br><span class="line">[&amp;] 按引用捕获所有外部变量</span><br><span class="line">[x,&amp;y] 按值捕获x，按引用捕获y</span><br></pre></td></tr></table></figure>



<h2 id="函数隐藏，函数重载，函数重写，多态性"><a href="#函数隐藏，函数重载，函数重写，多态性" class="headerlink" title="函数隐藏，函数重载，函数重写，多态性"></a>函数隐藏，函数重载，函数重写，多态性</h2><h3 id="函数隐藏-重定义"><a href="#函数隐藏-重定义" class="headerlink" title="函数隐藏&#x2F;重定义"></a>函数隐藏&#x2F;重定义</h3><p>基类和派生类函数名一致但参数列表无所谓的非虚函数，派生类默认访问派生类函数，也可以通过添加类限定符访问基类函数，例如: <code>B b; b.A::show();</code></p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个类中，函数名一致，但参数列表不一致，可看作是两个独立的函数。</p>
<h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h3><p>基类使用 virtual 关键字修饰成员函数，派生类重写此函数，函数名和参数列表均一致。</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>派生类存在函数重写，即重写了virtual修饰的函数，且存在基类指针指向派生类对象的情况</p>
<p> a编译时多态性：通过重载函数实现 。<br> b运行时多态性：通过虚函数实现。</p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>基类必须存在虚函数才能使用，其本质是查询虚函数表。</p>
<p>不能保证转换是否安全，但可以给出结果，指针或nullptr</p>
<h2 id="指针强行转换"><a href="#指针强行转换" class="headerlink" title="指针强行转换"></a>指针强行转换</h2><ol>
<li>静态类型检查失效：在编译时，编译器只能检查指针的静态类型，而不能检查指针所指向对象的动态类型。因此，如果将一个父类指针强制转换为子类指针，但实际指向的对象不是子类对象，那么在运行时可能会发生未定义行为，如访问非法内存地址、引起段错误等。</li>
<li>数据截断：由于子类对象可能比父类对象更大，因此将子类指针强制转换为父类指针可能会导致数据截断。例如，如果一个子类对象有一个额外的成员变量，但将其强制转换为父类指针，那么访问该成员变量可能会导致未定义行为。</li>
<li>对象切片：当将子类对象赋值给父类对象时，只会复制父类部分的成员变量，而子类部分的成员变量将被忽略。这种现象被称为“对象切片”，可能会导致程序错误。</li>
</ol>
<p>因此，应该避免在 C++ 中进行父类和子类指针之间的强制类型转换，或者在进行转换之前进行动态类型检查，以确保指针所指向的对象的动态类型与转换后的类型相同。</p>
<h2 id="type-type-info"><a href="#type-type-info" class="headerlink" title="type &amp; type_info"></a>type &amp; type_info</h2><p>typeid晕眩符返回type_info类的引用.(头文件 <typeinfo>)</p>
<p>重载了 <code>==</code> 和<code>!==</code>运算符，用于类型的比较</p>
<p>可以用在多态场景，在运行阶段识别对象的数据类型</p>
<h2 id="泛编程"><a href="#泛编程" class="headerlink" title="泛编程"></a>泛编程</h2><p>自动推导类型，函数模板，类模板</p>
<h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>自动推导类型</p>
<p>用途如下：</p>
<blockquote>
<p>函数指针</p>
<p>模板中声明依赖模板参数的变量</p>
<p>模板中依赖模板参数的返回值</p>
<p>lambda表达式</p>
</blockquote>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>关键字可以用 typename 和 class，函数模板用typename，类模板用class</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br></pre></td></tr></table></figure>

<p>不能为虚函数和析构函数使用模板</p>
<p>使用函数模板时，尽量显示制定类型，没用到T时，必须明确数据类型</p>
<p>函数模板的具体化（尖括号内不写类型）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(参数列表)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级</p>
<p>具体化模板优先于常规模板，普通函数优先于具体化模板。</p>
<p>如果希望使用函数模板，可以用空模板参数<code>Swap&lt;&gt;(a,b)</code>强制使用函数模板</p>
<p>如果函数模板能产生更好地匹配，将优先于非函数模板</p>
<p>&#x3D;&#x3D;普通函数模板的声明和定义都要写在头文件中，而具体化模板可以分开写&#x3D;&#x3D;</p>
<h4 id="decltype推导类型"><a href="#decltype推导类型" class="headerlink" title="decltype推导类型"></a>decltype推导类型</h4><p><code>decltype(expression) var</code></p>
<blockquote>
<p>short a &#x3D; 5;</p>
<p>decltype(a) da;  da-&gt;short</p>
<p>decltype((a)) da&#x3D;a; (引用要初始化)da-&gt;short &amp;</p>
<p>decltype(++a) da; da-&gt;short&amp;</p>
<p>decltype(func()) da; da-&gt;func的返回值类型</p>
<p>decltype(func) da; da-&gt;int da(), 即func的函数类型</p>
<p>decltype((func)) da &#x3D; func;(引用要初始化) da-&gt;int (&amp;da)(), 即函数的引用类型 </p>
<p>decltype(func) *da &#x3D; func;  da-&gt; int (*da)(), 即函数指针类型;</p>
</blockquote>
<h4 id="decltype-auto-区别"><a href="#decltype-auto-区别" class="headerlink" title="decltype &amp; auto 区别"></a>decltype &amp; auto 区别</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) da;		<span class="comment">// 不会执行函数</span></span><br><span class="line"><span class="keyword">auto</span> db = <span class="built_in">func</span>();			<span class="comment">// 会执行函数，因为需要推导表达式</span></span><br></pre></td></tr></table></figure>



<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="调用DLL文件"><a href="#调用DLL文件" class="headerlink" title="调用DLL文件"></a>调用DLL文件</h2><p>在C++中调用DLL文件，可以使用以下步骤：</p>
<ol>
<li>在C++代码中包含Windows.h头文件。</li>
<li>使用LoadLibrary函数加载DLL文件。该函数返回一个句柄，可以用于后续的函数调用。</li>
<li>使用GetProcAddress函数获取DLL文件中的函数地址。该函数需要传递DLL文件的句柄和函数名。</li>
<li>将获取的函数地址转换为函数指针，并调用该函数。可以使用typedef来定义函数指针类型，以便更方便地调用函数。</li>
</ol>
<p>下面是一个简单的示例代码，演示如何在C++中调用DLL文件中的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*AddFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 定义函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HINSTANCE hDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;MyDll.dll&quot;</span>); <span class="comment">// 加载DLL文件</span></span><br><span class="line">    <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load DLL file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddFunc addFunc = (AddFunc)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;Add&quot;</span>); <span class="comment">// 获取函数地址</span></span><br><span class="line">    <span class="keyword">if</span> (addFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to get function address.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">addFunc</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hDll); <span class="comment">// 卸载DLL文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，我们首先使用LoadLibrary函数加载了一个名为MyDll.dll的DLL文件。然后使用GetProcAddress函数获取了该文件中名为Add的函数的地址，并将其转换为函数指针类型AddFunc。最后，我们调用了该函数并输出了结果。最后使用FreeLibrary函数卸载了DLL文件。</p>
<h2 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h2><p>输出流：ostream (output stream)<br>输出流：istream (input stream)<br>输入输出流：iostream<br>写操作（输出）的文件类：ofstream<br>读操作（输入）的文件类：ifstream<br>可同时读写操作的文件类：fstream (file stream)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对文件的读取示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];                       <span class="comment">//定义一个数组，用来存放字符</span></span><br><span class="line">    <span class="function">ifstream <span class="title">examplefile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;    <span class="comment">//声明一个对象与要读的文件联系</span></span><br><span class="line">    <span class="keyword">if</span> (! examplefile.<span class="built_in">is_open</span>())            <span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error opening file&quot;</span>; <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!examplefile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        examplefile.<span class="built_in">getline</span>(buffer,<span class="number">100</span>);</span><br><span class="line">        cout&lt;&lt;buffer&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><p>ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)，用于关闭C&#x2F;C++的标准流的同步，还将cin,cout与cerr分离，避免cin，cout同步问题</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>如果希望在最终读入的字符串中保留空格，可以使用getline函数<br>getline(cin , s1);</p>
<h3 id="1-字符串构造函数"><a href="#1-字符串构造函数" class="headerlink" title="1.字符串构造函数"></a>1.字符串构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1;               <span class="comment">//生成空字符串</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;  <span class="comment">//生成&quot;1234456789&quot;的复制品</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot;</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;012345&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为&quot;01234&quot;</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;       <span class="comment">//结果为&quot;11111&quot;</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为&quot;3456789&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-string大小和容量"><a href="#2-string大小和容量" class="headerlink" title="2.string大小和容量"></a>2.string大小和容量</h3><ol>
<li>size()和length()：返回string对象的字符个数，他们执行效果相同。</li>
<li>max_size()：返回string对象最多包含的字符数，超出会抛出length_error异常</li>
<li>capacity()：重新分配内存之前，string对象能包含的最大字符数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;1234567&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;      <span class="comment">//7</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;length=&quot;</span> &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;  <span class="comment">//7</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;max_size=&quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl; <span class="comment">// 4294967294</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h3 id="3-string的字符串比较"><a href="#3-string的字符串比较" class="headerlink" title="3.string的字符串比较"></a>3.string的字符串比较</h3><ol>
<li>C ++字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小(前面减后面)<br>同时，string (“aaaa”) &lt; string(“aaaaa”)。</li>
<li>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。<br>他返回一个整数来表示比较结果，返回值意义如下：0：相等 1：大于 -1：小于 (A的ASCII码是65，a的ASCII码是97)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">A</span><span class="params">(<span class="string">&quot;aBcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">B</span><span class="params">(<span class="string">&quot;Abcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">C</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">D</span><span class="params">(<span class="string">&quot;123dfg&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aBcd&quot; 和 &quot;Abcd&quot;比较------ a &gt; A</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.compare(B)：&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(B)&lt;&lt; endl;                          <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cd&quot; 和 &quot;Abcd&quot;比较------- c &gt; A</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B):&quot;</span> &lt;&lt;A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B)&lt;&lt; endl;                <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cd&quot; 和 &quot;cd&quot;比较 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B, 2, 3):&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由结果看出来：0表示下标，3表示长度</span></span><br><span class="line"><span class="comment">// &quot;123&quot; 和 &quot;123&quot;比较 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C.compare(0, 3, D, 0, 3)&quot;</span> &lt;&lt;C.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, D, <span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl;    <span class="comment">// 结果：0</span></span><br></pre></td></tr></table></figure>

<h3 id="4-string的插入"><a href="#4-string的插入" class="headerlink" title="4.string的插入"></a>4.string的插入</h3><ol>
<li>push_back() : 在尾部插入字符</li>
<li>insert(pos, char) : 在 pos前插入字符串char</li>
</ol>
<h3 id="5-string字符串拼接"><a href="#5-string字符串拼接" class="headerlink" title="5.string字符串拼接"></a>5.string字符串拼接</h3><ol>
<li>append() : 尾部加入字符串</li>
<li><ul>
<li>: 尾部加入字符串</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：append()</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">append</span>(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s1:&quot;</span>&lt;&lt;s1&lt;&lt;endl; <span class="comment">// s1:abcdef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：+ 操作符</span></span><br><span class="line">string s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">/*s2 += &quot;def&quot;;*/</span></span><br><span class="line">string s3 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">s2 += s3.<span class="built_in">c_str</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s2:&quot;</span>&lt;&lt;s2&lt;&lt;endl; <span class="comment">// s2:abcdef</span></span><br></pre></td></tr></table></figure>

<h3 id="6-string遍历"><a href="#6-string遍历" class="headerlink" title="6.string遍历"></a>6.string遍历</h3><p>迭代器 或者 下标法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string::iterator iter = s1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>( ; iter &lt; s1.<span class="built_in">end</span>() ; iter++)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;*iter;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>str[i] &#x2F; str.at(i);</p>
<h3 id="7-string的删除"><a href="#7-string的删除" class="headerlink" title="7.string的删除"></a>7.string的删除</h3><ol>
<li>iterator erase(iterator p);&#x2F;&#x2F;删除字符串中p所指的字符</li>
<li>iterator erase(iterator first, iterator last);&#x2F;&#x2F;删除字符串中迭代器区间 <code>[first,last)</code>上所有字符  左闭右开</li>
<li>string&amp; erase(size_t pos &#x3D; 0, size_t len &#x3D; npos);&#x2F;&#x2F;删除字符串中从索引位置pos开始的len个字符</li>
<li>void clear();&#x2F;&#x2F;删除字符串中所有字符</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// s1.erase(s1.begin()+1);              // 结果：13456789</span></span><br><span class="line"><span class="comment">// s1.erase(s1.begin()+1,s1.end()-2);   // 结果：189</span></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">1</span>,<span class="number">6</span>);                       <span class="comment">// 结果：189</span></span><br><span class="line">string::iterator iter = s1.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>

<h3 id="8-string的字符替换"><a href="#8-string的字符替换" class="headerlink" title="8.string的字符替换"></a>8.string的字符替换</h3><ol>
<li>string&amp; replace(size_t pos, size_t n, const char *s);&#x2F;&#x2F;将当前字符串从pos索引开始的n个字符，替换成字符串s</li>
<li>string&amp; replace(size_t pos, size_t n, size_t n1, char c); &#x2F;&#x2F;将当前字符串从pos索引开始的n个字符，替换成n1个字符c</li>
<li>string&amp; replace(iterator i1, iterator i2, const char* s);&#x2F;&#x2F;将当前字符串 <code>[i1,i2)</code>区间中的字符串替换为字符串s</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello,world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s1.<span class="built_in">size</span>()&lt;&lt;endl;                     <span class="comment">// 结果：12</span></span><br><span class="line">s1.<span class="built_in">replace</span>(s1.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);           <span class="comment">// 结果：hello,world.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的6表示下标  5表示长度</span></span><br><span class="line">s1.<span class="built_in">replace</span>(<span class="number">6</span>,<span class="number">5</span>,<span class="string">&quot;girl&quot;</span>);                    <span class="comment">// 结果：hello,girl.</span></span><br><span class="line"><span class="comment">// s1.begin(),s1.begin()+5 是左闭右开区间</span></span><br><span class="line">s1.<span class="built_in">replace</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&quot;boy&quot;</span>); <span class="comment">// 结果：boy,girl.</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="9-string大小写替换"><a href="#9-string大小写替换" class="headerlink" title="9.string大小写替换"></a>9.string大小写替换</h3><ol>
<li>tolower(); toupper();</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">   s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>STL的transform算法配合的toupper和tolower</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line">string result;</span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);</span><br></pre></td></tr></table></figure>

<h3 id="10-string的查找"><a href="#10-string的查找" class="headerlink" title="10.string的查找"></a>10.string的查找</h3><ol>
<li><p>size_t find (constchar* s, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串</p>
<p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串</p>
</li>
<li><p>size_t find (charc, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</p>
<p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</p>
</li>
<li><p>size_t rfind (constchar* s, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</p>
<p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</p>
</li>
<li><p>size_t rfind (charc, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</p>
<p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</p>
</li>
<li><p>size_tfind_first_of (const char* s, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</p>
<p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</p>
</li>
<li><p>size_tfind_first_not_of (const char* s, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p>
<p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p>
</li>
<li><p>size_t find_last_of(const char* s, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p>
<p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p>
</li>
<li><p>size_tfind_last_not_of (const char* s, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串查找-----找到后返回首字母在字符串中的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 查找一个字符串</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;        <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;i&#x27;</span>,<span class="number">6</span>) &lt;&lt; endl;            <span class="comment">// 结果是：11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;       <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从字符串的末尾开始查找字符</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&#x27;i&#x27;</span>) &lt;&lt; endl;             <span class="comment">// 结果是：18-------因为是从末尾开始查找，所以返回第一次找到的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 在该字符串中查找第一个属于字符串s的字符</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_first_of</span>(<span class="string">&quot;13br98&quot;</span>) &lt;&lt; endl;  <span class="comment">// 结果是：4---b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl; <span class="comment">// 结果是：4</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;  <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_last_of</span>(<span class="string">&quot;13r98&quot;</span>) &lt;&lt; endl;               <span class="comment">// 结果是：19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;teac&quot;</span>) &lt;&lt; endl;            <span class="comment">// 结果是：21</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-string的排序-sort-s-begin-s-end"><a href="#11-string的排序-sort-s-begin-s-end" class="headerlink" title="11.string的排序 sort(s.begin(),s.end())"></a>11.string的排序 sort(s.begin(),s.end())</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;cdefba&quot;</span>;</span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s:&quot;</span>&lt;&lt;s&lt;&lt;endl;     <span class="comment">// 结果：abcdef</span></span><br></pre></td></tr></table></figure>

<h3 id="12-string的分割-截取-strtok-substr"><a href="#12-string的分割-截取-strtok-substr" class="headerlink" title="12.string的分割&#x2F;截取 strtok() &#x2F; substr()"></a>12.string的分割&#x2F;截取 strtok() &#x2F; substr()</h3><ol>
<li>strtok()</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;I,am,a,student; hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *split = <span class="string">&quot;,; !&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p2 = <span class="built_in">strtok</span>(str,split);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>substr()</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s1.<span class="built_in">substr</span>(<span class="number">2</span>,<span class="number">5</span>); <span class="comment">// 结果：23456-----参数5表示：截取的字符串的长度</span></span><br></pre></td></tr></table></figure>

<h3 id="13-string-char-转换"><a href="#13-string-char-转换" class="headerlink" title="13. string char 转换"></a>13. string char 转换</h3><p>将数值 val 转换为 string 。val 可以是任何算术类型（int、浮点型等）。<br><code>string s = to_string(val)</code></p>
<h3 id="14-string-reverse反转"><a href="#14-string-reverse反转" class="headerlink" title="14. string reverse反转"></a>14. string reverse反转</h3><p>reverse(str.begin(),str.end());<br>reverse还可用于数组 reverse(array, array+arrat.lenth())<br>STL任何容器都可以。</p>
<h3 id="sscanf-const-char-str-const-char-format-…"><a href="#sscanf-const-char-str-const-char-format-…" class="headerlink" title="sscanf(const char *str, const char *format, …);"></a>sscanf(const char *str, const char *format, …);</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> converted = <span class="built_in">sscanf</span>(<span class="string">&quot;20191103&quot;</span>, <span class="string">&quot;%04d%02d%02d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;converted=%d, year=%d, month=%d, day=%d/n&quot;</span>, converted, year, month, day);</span><br></pre></td></tr></table></figure>

<h3 id="string-转-time-t"><a href="#string-转-time-t" class="headerlink" title="string 转 time_t"></a>string 转 time_t</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux下存储时间常见的有两种存储方式，一个是从1970年到现在经过了多少秒，一个是用一个结构来分别存储年月日时分秒的。</span></span><br><span class="line"><span class="comment">//time_t 这种类型就是用来存储从1970年到现在经过了多少秒，要想更精确一点，可以用结构struct timeval，它精确到微妙。</span></span><br><span class="line"><span class="comment">// 从1970-1-1 00：00：00 过了多少秒</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">time_t</span>&#123;</span><br><span class="line">   <span class="type">long</span> t_sec;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> tv_sec; <span class="comment">/*秒*/</span></span><br><span class="line">    <span class="type">long</span> tv_usec; <span class="comment">/*微秒*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;  <span class="comment">/*秒，正常范围0-59， 但允许至61*/</span></span><br><span class="line">    <span class="type">int</span> tm_min;  <span class="comment">/*分钟，0-59*/</span></span><br><span class="line">    <span class="type">int</span> tm_hour; <span class="comment">/*小时， 0-23*/</span></span><br><span class="line">    <span class="type">int</span> tm_mday; <span class="comment">/*日，即一个月中的第几天，1-31*/</span></span><br><span class="line">    <span class="type">int</span> tm_mon;  <span class="comment">/*月， 从一月算起，0-11*/</span>  <span class="number">1</span>+p-&gt;tm_mon;</span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">/*年， 从1900至今已经多少年*/</span>  <span class="number">1900</span>＋ p-&gt;tm_year;</span><br><span class="line">    <span class="type">int</span> tm_wday; <span class="comment">/*星期，一周中的第几天， 从星期日算起，0-6*/</span></span><br><span class="line">    <span class="type">int</span> tm_yday; <span class="comment">/*从今年1月1日到目前的天数，范围0-365*/</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">/*日光节约时间的旗标*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span>  time1 = <span class="built_in">time</span>(<span class="literal">NULL</span>);<span class="comment">//获取系统时间，单位为秒;</span></span><br><span class="line">tm* t = <span class="built_in">localtime</span>(&amp;time1); <span class="comment">//将换取的time_t时间转换为 struct tm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *t)</span></span>; <span class="comment">//取得从1970年1月1日至今的秒数  </span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span></span>; <span class="comment">//将结构中的信息转换为真实世界的时间，以字符串的形式显示  </span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span></span>; <span class="comment">//将timep转换为真是世界的时间，以字符串显示，它和asctime不同就在于传入的参数形式不一样  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="built_in">gmtime</span>(<span class="type">const</span> <span class="type">time_t</span> *timep); <span class="comment">//将time_t表示的时间转换为没有经过时区转换的UTC时间，是一个struct tm结构指针   </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span> *timep); <span class="comment">//和gmtime类似，但是它是经过时区转换的时间。  </span></span><br><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span></span>; <span class="comment">//将struct tm 结构的时间转换为从1970年至今的秒数  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>; <span class="comment">//返回当前距离1970年的秒数和微妙数，后面的tz是时区，一般不用  </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time2)</span></span>; <span class="comment">//返回两个时间相差的秒数  </span></span><br></pre></td></tr></table></figure>





<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ol>
<li><p>01背包，物品最多只能放一次</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;=w[i])	dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]]+v[i]);	<span class="comment">//从上一行找</span></span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 降为一维数组</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=w[i];j--)&#123;	<span class="comment">// 从后向前便利，只会计算一次</span></span><br><span class="line">		dp[j] = max(dp[j], dp[j-w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全背包问题，物品可重复放</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 二维</span><br><span class="line"><span class="type">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">			dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j-w[i]] + v[i]); <span class="comment">// 与01区别是从当前行找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 一维</span><br><span class="line"><span class="type">int</span> dp[n_1] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=n;j++)&#123;		<span class="comment">// 从前向后便利，多次计算之前的</span></span><br><span class="line">		dp[j] = max(dp[j], dp[j-w[i]] + v[i]);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ruomio.github.io">Papillon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ruomio.github.io/2024/02/19/CC++/">https://ruomio.github.io/2024/02/19/CC++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ruomio.github.io" target="_blank">Papillon's electroic brain</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/image1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/20/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF/" title="前后端问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前后端问题</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/09/ArchLinux/" title="Linux常用操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux常用操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/12/22/ysyx-report-20241222/" title="ysyx_report_20241222"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-22</div><div class="title">ysyx_report_20241222</div></div></a></div><div><a href="/2025/01/05/ysyx-report-20250105/" title="ysyx_report_20250105"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-05</div><div class="title">ysyx_report_20250105</div></div></a></div><div><a href="/2025/02/16/ysyx-report-20250216/" title="ysyx_report_20250216"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-16</div><div class="title">ysyx_report_20250216</div></div></a></div><div><a href="/2025/03/02/ysyx-report-20250302/" title="ysyx_report_20250302"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-02</div><div class="title">ysyx_report_20250302</div></div></a></div><div><a href="/2025/03/10/ysyx-report-lightsss-graft/" title="ysyx_report_lightsss_graft"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-10</div><div class="title">ysyx_report_lightsss_graft</div></div></a></div><div><a href="/2025/03/16/ysyx-report-20250316/" title="ysyx_report_20250316"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-16</div><div class="title">ysyx_report_20250316</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/image1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Papillon</div><div class="author-info__description">Keep learning and keep new</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ruomio"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ruomio" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:p1065940593@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C"><span class="toc-number">1.</span> <span class="toc-text">C</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">函数指针与回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-Callback-Function"><span class="toc-number">2.2.</span> <span class="toc-text">回调函数 Callback Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">I&#x2F;O 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">2.3.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">2.3.2.</span> <span class="toc-text">poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">2.3.3.</span> <span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">2.4.</span> <span class="toc-text">动态静态链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">2.4.1.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%BA%93"><span class="toc-number">2.5.</span> <span class="toc-text">编译库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%93"><span class="toc-number">2.6.</span> <span class="toc-text">使用库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F-%E5%8A%A8%E6%80%81-%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.6.0.1.</span> <span class="toc-text">显式(动态)加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text">查看命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nm%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.1.</span> <span class="toc-text">nm命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ldd%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.2.</span> <span class="toc-text">ldd命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">常见设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PIMPL"><span class="toc-number">3.2.</span> <span class="toc-text">PIMPL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-1"><span class="toc-number">5.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="toc-number">5.1.</span> <span class="toc-text">左值与右值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="toc-number">5.1.1.</span> <span class="toc-text">左值右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">左值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">5.2.</span> <span class="toc-text">移动语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="toc-number">5.2.1.</span> <span class="toc-text">值类别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%AE%B9%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">STL容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-%E4%B8%8E-static"><span class="toc-number">6.1.</span> <span class="toc-text">inline 与 static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">虚函数与纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%EF%BC%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%8C%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%EF%BC%8C%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">函数隐藏，函数重载，函数重写，多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F-%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="toc-number">6.4.1.</span> <span class="toc-text">函数隐藏&#x2F;重定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.4.2.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99"><span class="toc-number">6.4.3.</span> <span class="toc-text">函数重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">6.4.4.</span> <span class="toc-text">多态性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">6.5.</span> <span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%BC%BA%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.6.</span> <span class="toc-text">指针强行转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-type-info"><span class="toc-number">6.7.</span> <span class="toc-text">type &amp; type_info</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E7%BC%96%E7%A8%8B"><span class="toc-number">6.8.</span> <span class="toc-text">泛编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.8.1.</span> <span class="toc-text">auto关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.8.2.</span> <span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype%E6%8E%A8%E5%AF%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.8.2.1.</span> <span class="toc-text">decltype推导类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype-auto-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.8.2.2.</span> <span class="toc-text">decltype &amp; auto 区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">6.8.3.</span> <span class="toc-text">类模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">6.9.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8DLL%E6%96%87%E4%BB%B6"><span class="toc-number">6.10.</span> <span class="toc-text">调用DLL文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-1"><span class="toc-number">6.11.</span> <span class="toc-text">文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.12.</span> <span class="toc-text">输入输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">6.13.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.13.1.</span> <span class="toc-text">1.字符串构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-string%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%AE%B9%E9%87%8F"><span class="toc-number">6.13.2.</span> <span class="toc-text">2.string大小和容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-string%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">6.13.3.</span> <span class="toc-text">3.string的字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-string%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">6.13.4.</span> <span class="toc-text">4.string的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">6.13.5.</span> <span class="toc-text">5.string字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-string%E9%81%8D%E5%8E%86"><span class="toc-number">6.13.6.</span> <span class="toc-text">6.string遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-string%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">6.13.7.</span> <span class="toc-text">7.string的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-string%E7%9A%84%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2"><span class="toc-number">6.13.8.</span> <span class="toc-text">8.string的字符替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-string%E5%A4%A7%E5%B0%8F%E5%86%99%E6%9B%BF%E6%8D%A2"><span class="toc-number">6.13.9.</span> <span class="toc-text">9.string大小写替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-string%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">6.13.10.</span> <span class="toc-text">10.string的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-string%E7%9A%84%E6%8E%92%E5%BA%8F-sort-s-begin-s-end"><span class="toc-number">6.13.11.</span> <span class="toc-text">11.string的排序 sort(s.begin(),s.end())</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-string%E7%9A%84%E5%88%86%E5%89%B2-%E6%88%AA%E5%8F%96-strtok-substr"><span class="toc-number">6.13.12.</span> <span class="toc-text">12.string的分割&#x2F;截取 strtok() &#x2F; substr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-string-char-%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.13.13.</span> <span class="toc-text">13. string char 转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-string-reverse%E5%8F%8D%E8%BD%AC"><span class="toc-number">6.13.14.</span> <span class="toc-text">14. string reverse反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sscanf-const-char-str-const-char-format-%E2%80%A6"><span class="toc-number">6.13.15.</span> <span class="toc-text">sscanf(const char *str, const char *format, …);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E8%BD%AC-time-t"><span class="toc-number">6.13.16.</span> <span class="toc-text">string 转 time_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">6.13.17.</span> <span class="toc-text">常用函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">7.1.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.1.</span> <span class="toc-text">背包问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/30/ysyx-report-20250330/" title="ysyx_report_20250330">ysyx_report_20250330</a><time datetime="2025-03-30T09:36:00.000Z" title="发表于 2025-03-30 17:36:00">2025-03-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/16/ysyx-report-20250316/" title="ysyx_report_20250316">ysyx_report_20250316</a><time datetime="2025-03-16T09:55:41.000Z" title="发表于 2025-03-16 17:55:41">2025-03-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/manuals/all/" title="Manuals_all">Manuals_all</a><time datetime="2025-03-11T07:51:18.000Z" title="发表于 2025-03-11 15:51:18">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/10/ysyx-report-lightsss-graft/" title="ysyx_report_lightsss_graft">ysyx_report_lightsss_graft</a><time datetime="2025-03-10T05:20:15.000Z" title="发表于 2025-03-10 13:20:15">2025-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/02/ysyx-report-20250302/" title="ysyx_report_20250302">ysyx_report_20250302</a><time datetime="2025-03-02T09:33:29.000Z" title="发表于 2025-03-02 17:33:29">2025-03-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Papillon</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>