<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ysyx_report_20250330</title>
      <link href="/2025/03/30/ysyx-report-20250330/"/>
      <url>/2025/03/30/ysyx-report-20250330/</url>
      
        <content type="html"><![CDATA[<h1 id="一生一芯组会汇报-分享"><a href="#一生一芯组会汇报-分享" class="headerlink" title="一生一芯组会汇报&#x2F;分享"></a>一生一芯组会汇报&#x2F;分享</h1><p>内蒙古大学-彭培智</p><p>ysyx_24080020</p><p>B阶段</p><p>2025.03.30</p><h1 id="近期进展"><a href="#近期进展" class="headerlink" title="近期进展"></a>近期进展</h1><ol><li>校准访存延迟</li><li>解决yosys-sta bug （一个变量未初始化）</li><li>实现icache</li></ol><h1 id="卡了一段bug"><a href="#卡了一段bug" class="headerlink" title="卡了一段bug"></a>卡了一段bug</h1><ol><li>无</li></ol><h1 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h1><p>cachesim<br>已完成对nemu的改造，可以运行soc的程序镜像</p><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1>]]></content>
      
      
      <categories>
          
          <category> ysyx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> verilog </tag>
            
            <tag> riscv32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx_report_20250316</title>
      <link href="/2025/03/16/ysyx-report-20250316/"/>
      <url>/2025/03/16/ysyx-report-20250316/</url>
      
        <content type="html"><![CDATA[<h1 id="一生一芯组会汇报-分享"><a href="#一生一芯组会汇报-分享" class="headerlink" title="一生一芯组会汇报&#x2F;分享"></a>一生一芯组会汇报&#x2F;分享</h1><p>内蒙古大学-彭培智</p><p>ysyx_24080020</p><p>B阶段</p><p>2025.03.16</p><h1 id="近期进展"><a href="#近期进展" class="headerlink" title="近期进展"></a>近期进展</h1><ol><li>nvboard 接入uart</li><li>nvboard 接入 vga</li><li>chiplink</li><li>统计ipc</li></ol><h1 id="卡了一段bug"><a href="#卡了一段bug" class="headerlink" title="卡了一段bug"></a>卡了一段bug</h1><ol><li>nvboard 更新频率问题导致vga显示不正确。</li></ol><h1 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h1><p>性能评估</p><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1>]]></content>
      
      
      <categories>
          
          <category> ysyx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> verilog </tag>
            
            <tag> riscv32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manuals_all</title>
      <link href="/2025/03/11/manuals/all/"/>
      <url>/2025/03/11/manuals/all/</url>
      
        <content type="html"><![CDATA[<p><a href="/manuals/AXI-SPEC.pdf">axi-spec</a></p><p><a href="/manuals/RISC-V-Reader-Chinese-v2p12017.pdf">riscv-reader</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ysyx_report_lightsss_graft</title>
      <link href="/2025/03/10/ysyx-report-lightsss-graft/"/>
      <url>/2025/03/10/ysyx-report-lightsss-graft/</url>
      
        <content type="html"><![CDATA[<h1 id="在npc中移植lightsss"><a href="#在npc中移植lightsss" class="headerlink" title="在npc中移植lightsss"></a>在npc中移植lightsss</h1><h2 id="从炸盘的痛苦中解脱出来"><a href="#从炸盘的痛苦中解脱出来" class="headerlink" title="从炸盘的痛苦中解脱出来"></a>从炸盘的痛苦中解脱出来</h2><hr><h2 id="What’s-the-LightSSS"><a href="#What’s-the-LightSSS" class="headerlink" title="What’s the LightSSS?"></a>What’s the LightSSS?</h2><p>lightSSS是开源香山的工具组件之一，官网介绍如下：</p><ul><li>在仿真调试过程中，并不需要完整过程的波形，只需要在仿真出错的时候把前面一段时间内的波形保存即可。Verilator等仿真器提供了持久化保存电路状态的snapshot功能，仿真出错时可以调用这个功能生成相应的状态文件，复现错误的时候可以用这个文件从特定电路状态开始跑仿真。但这个功能的局限性有以下几点：<ul><li>只能保存RTL电路的状态，其他仿真的部分比如参考模型、DRAMSim3等的状态不能被保存</li><li>而且当电路规模比较大的时候，保存电路状态的存储开销比较大</li></ul></li><li>为此我们开发了轻量级的仿真快照工具lightSSS，它可以在仿真进程出错时自动保存出错点附近的波形和debug信息而不需要经过电路状态文件这个中间层。</li></ul><hr><h2 id="lightSSS-原理"><a href="#lightSSS-原理" class="headerlink" title="lightSSS 原理"></a>lightSSS 原理</h2><p>这里我简单说下，详细讲解可观看 王植鑫同学的分享会————《香山LightSSS剖析》， 强烈推荐 :)</p><p>利用fork函数(对当前进程进行bit级复制)来保留程序在不同状态的快照，每隔一段时间就fork新的子进程，并将多余的子进程结束，每个子进程被创建出来是都会被阻塞，直到父进程出错时，去唤醒最老的子进程，结束最老子进程的阻塞状态，并开启波形跑子进程。 这样就得到了从子进程被创建的那个状态到出错的状态之间的所有波形信息。</p><hr><h2 id="缘从何起？"><a href="#缘从何起？" class="headerlink" title="缘从何起？"></a>缘从何起？</h2><p>我在排查sdram的bug时，因为sdram的地址空间比较大，开启波形仿真时，会生成巨大的波形文件，非常占据磁盘空间，而且使用gtkwave打开太大的波形文件会非常缓慢。</p><p>所以刚开始我设置了开始仿真的步长，即对周期进行计数，当周期数大于某个数值时才保存波形，但是对于不同的错误，我并不能事先知道出错时大致的周期范围，所以我在调试bug时花费了大量的时间去定位出问题时周期范围，哪怕使用二分法去定位，依旧耗费不少时间。</p><p>直到从一生一芯的分享会中得知了今天的主角<code>lightSSS</code>！</p><hr><h2 id="开始移植"><a href="#开始移植" class="headerlink" title="开始移植"></a>开始移植</h2><p>找到香山项目工具集的子项目仓库地址：<a href="https://github.com/OpenXiangShan/difftest">OpenXiangshan&#x2F;difftest</a>: <a href="https://github.com/OpenXiangShan/difftest">https://github.com/OpenXiangShan/difftest</a> </p><p>在 <code>src/test/csrc/common/</code> 目录中有 <code>lightsss.h lightsss.cpp</code> 两个文件，添加到自己的npc目录环境中，记得要修改<code>Makefile</code>将这两个文件来编译他们。</p><p>简单看一下这两个文件： <a href="https://github.com/OpenXiangShan/difftest/blob/master/src/test/csrc/common/lightsss.h">lightsss.h</a> <a href="https://github.com/OpenXiangShan/difftest/blob/master/src/test/csrc/common/lightsss.cpp">lightsss.cpp</a></p><hr><h3 id="在哪里添加创建子进程-唤醒子进程等的逻辑？"><a href="#在哪里添加创建子进程-唤醒子进程等的逻辑？" class="headerlink" title="在哪里添加创建子进程&#x2F;唤醒子进程等的逻辑？"></a>在哪里添加创建子进程&#x2F;唤醒子进程等的逻辑？</h3><p>因为我们的difftest可以测试指令维度的正确性，所以我们可以在<code>exec_npc()</code>函数中每条指令执行完成后添加创建子进程的逻辑，并且判断全局变量<code>npc_state</code> 的状态（会在difftest函数中修改状态，和ref不等就会被修改）来修改共享内存中的<code>flag, notgood</code>变量，子进程此时在<code>shwait</code>函数中会跳出死循环，是否生成波形的逻辑也根据以上的两个变量来决定。这样就的到了预期的只在bug附近的波形文件, 大功告成，最后别忘了在父进程退出之前清理子进程，以免造成内存泄漏。</p><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exec_npc</span><span class="params">(n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(n; n&gt;<span class="number">0</span>; n--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(time_now - time_last &gt;= TIME_WAIT) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ischild) &#123;</span><br><span class="line">                do_fork();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exec_once(); <span class="comment">// the difftest will change npc_state</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(upc_state.state == NPC_ABORT)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    swich(npc_state) &#123;</span><br><span class="line">        <span class="keyword">case</span>(xxx): ...;</span><br><span class="line">        <span class="keyword">case</span>(NPC_ABORT): &#123;</span><br><span class="line">            <span class="keyword">if</span>(!ischild) &#123;</span><br><span class="line">                shinfo.notgood = <span class="literal">true</span>;</span><br><span class="line">                shinfo.flag = <span class="literal">true</span>;</span><br><span class="line">                wakeup_child();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            ...; <span class="comment">// other quit process</span></span><br><span class="line">            <span class="keyword">if</span>(!ischild) &#123;</span><br><span class="line">                do_clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="一些额外的修改"><a href="#一些额外的修改" class="headerlink" title="一些额外的修改"></a>一些额外的修改</h2><p>此时你会发现当父进程<code>assert</code>失败，或者自己手动<code>ctrl + c</code> 中断进程执行后，子进程并没有被清理，造成了内存泄漏，必须去手动清理遗留的子进程，非常的麻烦。<br>聪明如你马上就想到信号处理函数了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGINT, signal_handler); <span class="comment">// 注册SIGINT处理器 ctrl c</span></span><br><span class="line">signal(SIGTERM, signal_handler); <span class="comment">// 注册SIGTERM处理器 kill </span></span><br><span class="line">signal(SIGABRT, signal_handler_abort); <span class="comment">// 注册SIGTERM处理器 assert faile</span></span><br></pre></td></tr></table></figure><p>此时就需要对<code>lightsss.h lightsss.cpp</code> 进行一些细微的改动，因为c++的特性，成员函数会自带一个指针，不能与<code>signal</code> 函数的参数匹配，所以要讲用到的成员函数和成员变量声明成<code>static</code>类型，并在类的外部额外定义对应的函数或变量。</p><hr><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      
      
      <categories>
          
          <category> ysyx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> verilog </tag>
            
            <tag> riscv32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx_report_20250302</title>
      <link href="/2025/03/02/ysyx-report-20250302/"/>
      <url>/2025/03/02/ysyx-report-20250302/</url>
      
        <content type="html"><![CDATA[<h1 id="一生一芯组会汇报-分享"><a href="#一生一芯组会汇报-分享" class="headerlink" title="一生一芯组会汇报&#x2F;分享"></a>一生一芯组会汇报&#x2F;分享</h1><p>内蒙古大学-彭培智</p><p>ysyx_24080020</p><p>B阶段</p><p>2025.03.02</p><h1 id="近期进展"><a href="#近期进展" class="headerlink" title="近期进展"></a>近期进展</h1><ol><li>接入nvboard gpio</li><li>lightsss 改bug，assert失败或者ctrl c 终止时，子进程无法正常退出，造成内存泄漏；新增信号处理函数，支持assert失败时也保存波形。</li></ol><h1 id="卡了一段bug"><a href="#卡了一段bug" class="headerlink" title="卡了一段bug"></a>卡了一段bug</h1><ol><li>nvboard uart 试了很多办法都无法正常打印（打印乱码）<br> 思路：<br> – 计算仿真频率， 8000 insts &#x2F; s， 每条指令 36 时钟周期， 故仿真频率 288KHz，以此设置nvboard除数： 不正确<br> – 查波形，nvboard在每条指令执行后更新，查看tx信号引脚，发现14条指令后结束一字节的发送并发送停止位，到第21条指令后开始下一字节的发送，但是将nvboard的除数设置为14 or 21 也均不对， 目前卡在了这里，想问下大家思路。</li></ol><h1 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h1><p>通过nvboard测试串口输入功能</p><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1>]]></content>
      
      
      <categories>
          
          <category> ysyx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> verilog </tag>
            
            <tag> riscv32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx_report_20250216</title>
      <link href="/2025/02/16/ysyx-report-20250216/"/>
      <url>/2025/02/16/ysyx-report-20250216/</url>
      
        <content type="html"><![CDATA[<h1 id="一生一芯组会汇报-分享"><a href="#一生一芯组会汇报-分享" class="headerlink" title="一生一芯组会汇报&#x2F;分享"></a>一生一芯组会汇报&#x2F;分享</h1><p>内蒙古大学-彭培智</p><p>ysyx_24080020</p><p>B阶段</p><p>2025.02.16</p><h1 id="近期进展"><a href="#近期进展" class="headerlink" title="近期进展"></a>近期进展</h1><ol><li>sdram 实现</li><li>sdram 位扩展</li><li>sdran 字扩展</li><li>移植lightsss</li></ol><h1 id="卡了一段bug"><a href="#卡了一段bug" class="headerlink" title="卡了一段bug"></a>卡了一段bug</h1><ol><li>sdram的每个bank的active row各自独立，刚开始只保存了一个active row, 导致读写失败（控制器代码对于已保存的active row 不会先active 而是直接read&#x2F;write）</li></ol><h1 id="接下来的任务"><a href="#接下来的任务" class="headerlink" title="接下来的任务"></a>接下来的任务</h1><p>接入更多的外设，即接入nvboard</p><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1>]]></content>
      
      
      <categories>
          
          <category> ysyx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> verilog </tag>
            
            <tag> riscv32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx_report_20250105</title>
      <link href="/2025/01/05/ysyx-report-20250105/"/>
      <url>/2025/01/05/ysyx-report-20250105/</url>
      
        <content type="html"><![CDATA[<h1 id="ysyx分享-汇报"><a href="#ysyx分享-汇报" class="headerlink" title="ysyx分享&#x2F;汇报"></a>ysyx分享&#x2F;汇报</h1><p>内蒙古大学-彭培智</p><p>ysyx_24080025</p><p>B阶段</p><p>2025-01-05</p><h1 id="近期进展"><a href="#近期进展" class="headerlink" title="近期进展"></a>近期进展</h1><ol><li>UART 正确初始化</li><li>xip flash读取</li><li>psram 读写</li><li>QPI模式</li></ol><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ol><li>可以运行所有cpu-tests, 但是运行rtt时提示编译出的文件大小一异常，通过readelf 工具查看发现从data段开始偏移量错误。</li></ol><h1 id="接下来的进度"><a href="#接下来的进度" class="headerlink" title="接下来的进度"></a>接下来的进度</h1><p>bootloader 二级加载过程</p><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1>]]></content>
      
      
      <categories>
          
          <category> ysyx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> verilog </tag>
            
            <tag> riscv32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ysyx_report_20241222</title>
      <link href="/2024/12/22/ysyx-report-20241222/"/>
      <url>/2024/12/22/ysyx-report-20241222/</url>
      
        <content type="html"><![CDATA[<h1 id="一生一芯组会汇报-分享"><a href="#一生一芯组会汇报-分享" class="headerlink" title="一生一芯组会汇报&#x2F;分享"></a>一生一芯组会汇报&#x2F;分享</h1><p>内蒙古大学-彭培智</p><p>ysyx_24080020</p><p>B阶段</p><p>2024.12.22</p><h1 id="近期进展"><a href="#近期进展" class="headerlink" title="近期进展"></a>近期进展</h1><ol><li>仲裁器</li><li>xbar, uart, clint</li><li>接入ysyx_soc, 将axi-lite 修改为axi-full</li><li>修改nemu，添加mrom和sram, 为soc添加difftest</li><li>折腾 —— 为npc实现与sram之间的突发传输（非内存对齐状态下多读写事物）</li><li>全局变量写入，bootloader 将data段复制到sram，并将bss段初始化</li></ol><h1 id="接下来的进度"><a href="#接下来的进度" class="headerlink" title="接下来的进度"></a>接下来的进度</h1><p>通过串口输出</p><h1 id="卡进度"><a href="#卡进度" class="headerlink" title="卡进度"></a>卡进度</h1><p>还以为 ‘mem-test测试内存访问’ 就是要实现突发传输呢，结果才发现非对齐访问内存时，编译器优化只会生成lb,sb, 故npc与sram之间不会发生突发传输…</p><p>白实现了 :(</p><h1 id="DONE"><a href="#DONE" class="headerlink" title="DONE"></a>DONE</h1>]]></content>
      
      
      <categories>
          
          <category> ysyx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> verilog </tag>
            
            <tag> riscv32 </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>door_lock</title>
      <link href="/2024/03/05/door-lock/"/>
      <url>/2024/03/05/door-lock/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在消费升级渗透在各个领域的今天，国民消费发生着巨大的变化，与每个人息息相关的家居行业也是如此。现今，越来越多的智能家居产品出现在普通老百姓的生活中，智能照明、智能窗帘、智能扫地机器人等各种智能产品都给人们的生活带来了极大的便利。智能门锁作为智能家居中重要的一环，也成为消费者家居智能化的重要选择。智能相比市面的机械门锁更加安全、更智能、更人性化而得到市场的认可，在智能门锁行业里，不少世界500强企业也在智能门锁上进行产品布局，像中国小米公司就生产智能门锁，致力打造智慧家庭，市场智能门锁能够支持五种解锁方式，支持指纹、手机、门禁门、按键密码、钥匙解锁功能。可以说是智能家庭必不可少的成员。</p><h1 id="项目所用到的主要技术"><a href="#项目所用到的主要技术" class="headerlink" title="项目所用到的主要技术"></a>项目所用到的主要技术</h1><ol><li>UART串口协议</li><li>MQTT网络协议</li><li>PWM控制舵机</li><li>Spring-boot,VUE</li></ol><h1 id="元器件-暂定-时间允许情况下，重新设计PCB打板集成"><a href="#元器件-暂定-时间允许情况下，重新设计PCB打板集成" class="headerlink" title="元器件(暂定,时间允许情况下，重新设计PCB打板集成)"></a>元器件(暂定,时间允许情况下，重新设计PCB打板集成)</h1><ol><li>STM32</li><li>ESP8266</li><li>舵机</li><li>TTL转串口</li></ol><h1 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h1><p><img src="/pic/flow.png" alt="flow"></p><h1 id="可能附加功能"><a href="#可能附加功能" class="headerlink" title="可能附加功能"></a>可能附加功能</h1><ol><li>指纹模块</li><li>NFC模块</li><li>密码模块</li></ol>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> MQTT </tag>
            
            <tag> ESP8266 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker_deploy_mariadb_mysql</title>
      <link href="/2024/02/24/docker-deploy-mariadb-mysql/"/>
      <url>/2024/02/24/docker-deploy-mariadb-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-配置MariaDB"><a href="#docker-配置MariaDB" class="headerlink" title="docker 配置MariaDB"></a>docker 配置MariaDB</h1><ol><li><p>拉取mariadb&#x2F;mysql docker 镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mariadb</span><br></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name mariadb -p 3306:3306 -e TZ=&quot;Asia/Shanghai&quot;  -e MYSQL_ROOT_PASSWORD=&#x27;your_password&#x27; -e MARIADB_PASSWORD=&#x27;your_password&#x27;  mariadb</span><br></pre></td></tr></table></figure></li><li><p>设置远程连接权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a. 进入容器</span></span><br><span class="line">docker exec -it mariadb /bin/bash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">b. 授权</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;your_password&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c. 刷新权限</span></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>重启容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart mariadb</span><br></pre></td></tr></table></figure></li><li><p>可以测试连接刚才设置的数据库</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程连接 x.x.x.x为公网ip地址</span></span><br><span class="line">mariadb -h x.x.x.x -u root -p &#x27;your_password&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地连接</span></span><br><span class="line">mariadb -u root -p &#x27;your_password&#x27;</span><br></pre></td></tr></table></figure></li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>要在云服务器厂商的控制台开启对应的端口规则，这里使用的默认端口3306</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mariadb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端问题</title>
      <link href="/2024/02/20/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF/"/>
      <url>/2024/02/20/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前端与后端-bug"><a href="#前端与后端-bug" class="headerlink" title="前端与后端 bug"></a>前端与后端 bug</h1><h2 id="前端-vue"><a href="#前端-vue" class="headerlink" title="前端 vue"></a>前端 vue</h2><h3 id="语法问题"><a href="#语法问题" class="headerlink" title="语法问题"></a>语法问题</h3><ul><li>在所有HTML中几乎都可以使用th: text属性，将接受的数据显示在标签内容中<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="comment">&lt;!--request作用域--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="comment">&lt;!--session作用域--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="comment">&lt;!--对象作用域--&gt;</span></span><br></pre></td></tr></table></figure></li><li>th: each用来遍历对象来展示; th:if 做判断</li><li>th: unless 相当于else</li><li>th: switch 条件判断</li><li>th: case&#x3D;”1”</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;b:$&#123;list&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;b.userId&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;b.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;b.userPasswd&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>html表单属性名与对象类名不一致时，要是在参数前加上@RequestParam(“”)绑定</li></ul><h3 id="axios"><a href="#axios" class="headerlink" title="axios:"></a>axios:</h3><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法:"></a>get方法:</h4><ul><li>方式一</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url,&#123;</span><br><span class="line">    <span class="attr">params</span>:&#123;  </span><br><span class="line">        <span class="attr">username</span>:<span class="variable language_">this</span>.<span class="property">form</span>.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="variable language_">this</span>.<span class="property">form</span>.<span class="property">pwd</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">100</span>)&#123;  </span><br><span class="line">        <span class="comment">//进行页面跳转</span></span><br><span class="line">        <span class="variable language_">this</span>.$messsage(&#123;</span><br><span class="line">            <span class="attr">showClose</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">message</span>: result.<span class="property">data</span>.<span class="property">msg</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;success&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&quot;/home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//登录失败</span></span><br><span class="line">        <span class="variable language_">this</span>.$messsage(&#123;</span><br><span class="line">            <span class="attr">showClose</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">message</span>: result.<span class="property">data</span>.<span class="property">msg</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;error&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>方式二<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">get</span>(url/login?name=<span class="string">&quot; + </span></span><br><span class="line"><span class="string">    this.form.name +</span></span><br><span class="line"><span class="string">    &quot;</span>&amp;pwd=<span class="string">&quot; +</span></span><br><span class="line"><span class="string">    this.form.pwd</span></span><br><span class="line"><span class="string">).then(res  =&gt;&#123;</span></span><br><span class="line"><span class="string">    //结果</span></span><br><span class="line"><span class="string">    console.log(result);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># axios的post请求</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1.使用 qs.stringify()</span></span><br><span class="line"></span><br><span class="line"><span class="section">### qs.stringify() 作用:</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**将对象序列化成URL的形式**</span></span><br><span class="line"></span><br><span class="line">默认表单数据（json格式）：</span><br><span class="line"></span><br><span class="line">![<span class="string">image-20230114184055776</span>](<span class="link">/home/papillon/.config/Typora/typora-user-images/image-20230114184055776.png</span>)</span><br><span class="line"></span><br><span class="line">使用qs.stringify()之后的数据形式：</span><br><span class="line"></span><br><span class="line">![<span class="string">image-20230114184248892</span>](<span class="link">/home/papillon/.config/Typora/typora-user-images/image-20230114184248892.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### axios.post 代码</span></span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">this.$axios.post(&#x27;http://localhost:8090/register1&#x27;,</span></span><br><span class="line"><span class="code">                 // this.data=JSON.stringify(this.user),</span></span><br><span class="line"><span class="code">                 this.data=this.$qs.stringify(this.user),</span></span><br><span class="line"><span class="code">                 // this.data=(this.user)</span></span><br><span class="line"><span class="code">    )</span></span><br><span class="line"><span class="code">    .then(res=&gt;&#123;</span></span><br><span class="line"><span class="code">    if(res.data.code==100)&#123;</span></span><br><span class="line"><span class="code">        this.$message(&#123;</span></span><br><span class="line"><span class="code">            showClose: true,</span></span><br><span class="line"><span class="code">            message: res.data.msg,</span></span><br><span class="line"><span class="code">            type: &quot;success&quot;</span></span><br><span class="line"><span class="code">        &#125;);</span></span><br><span class="line"><span class="code">        // this.$router.push(&quot;/&quot;);</span></span><br><span class="line"><span class="code">        alert(&quot;注册成功！&quot;)</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    else&#123;</span></span><br><span class="line"><span class="code">        console.log(res+&quot;error-----------------------------&quot;);</span></span><br><span class="line"><span class="code">        this.$message(&#123;</span></span><br><span class="line"><span class="code">            showClose: true,</span></span><br><span class="line"><span class="code">            message: res.data.msg,</span></span><br><span class="line"><span class="code">            type: &quot;error&quot;</span></span><br><span class="line"><span class="code">        &#125;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;);</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="section">### UserController 代码</span></span><br><span class="line"></span><br><span class="line"><span class="code">```java</span></span><br><span class="line"><span class="code">// &quot;/register1&quot; 是传递 String username, String password</span></span><br><span class="line"><span class="code">@PostMapping(&quot;/register1&quot;)</span></span><br><span class="line"><span class="code">    public ResultVO signUp(String username, String password)&#123;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;register__1          :&quot;+username+password);</span></span><br><span class="line"><span class="code">        ResultVO insert = UserServiceImpl.Insert(username, password);</span></span><br><span class="line"><span class="code">        System.out.println(insert);</span></span><br><span class="line"><span class="code">        return insert;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 使用 Map来接收前端表单传来json数据</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 原理解释：</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> json格式为 &#123;username : &quot;aaaa&quot;, password : &quot;1111&quot;&#125;，与Map格式一致，故可用Map对象接收</span><br><span class="line"></span><br><span class="line"><span class="section">### axios.post 代码</span></span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">this.$axios.post(&#x27;http://localhost:8090/register2&#x27;,</span></span><br><span class="line"><span class="code">                 // this.data=JSON.stringify(this.user),</span></span><br><span class="line"><span class="code">                 // this.data=this.$qs.stringify(this.user),</span></span><br><span class="line"><span class="code">                 this.data=(this.user)</span></span><br><span class="line"><span class="code">    )</span></span><br><span class="line"><span class="code">    .then(res=&gt;&#123;</span></span><br><span class="line"><span class="code">    if(res.data.code==100)&#123;</span></span><br><span class="line"><span class="code">        this.$message(&#123;</span></span><br><span class="line"><span class="code">            showClose: true,</span></span><br><span class="line"><span class="code">            message: res.data.msg,</span></span><br><span class="line"><span class="code">            type: &quot;success&quot;</span></span><br><span class="line"><span class="code">        &#125;);</span></span><br><span class="line"><span class="code">        // this.$router.push(&quot;/&quot;);</span></span><br><span class="line"><span class="code">        alert(&quot;注册成功！&quot;)</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    else&#123;</span></span><br><span class="line"><span class="code">        console.log(res+&quot;error-----------------------------&quot;);</span></span><br><span class="line"><span class="code">        this.$message(&#123;</span></span><br><span class="line"><span class="code">            showClose: true,</span></span><br><span class="line"><span class="code">            message: res.data.msg,</span></span><br><span class="line"><span class="code">            type: &quot;error&quot;</span></span><br><span class="line"><span class="code">        &#125;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;);</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="section">### UserController代码</span></span><br><span class="line"></span><br><span class="line"><span class="code">```java</span></span><br><span class="line"><span class="code">// &quot;register2&quot; 用Map对象接收json形式数据</span></span><br><span class="line"><span class="code">@PostMapping(&quot;/register2&quot;)</span></span><br><span class="line"><span class="code">    public ResultVO signUp(@RequestBody Map&lt;String,String&gt; user)&#123;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;register__2       :&quot;+user);</span></span><br><span class="line"><span class="code">        ResultVO insert = UserServiceImpl.Insert(user.get(&quot;username&quot;), user.get(&quot;password&quot;));</span></span><br><span class="line"><span class="code">        System.out.println(insert);</span></span><br><span class="line"><span class="code">        return insert;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 3.使用实体类对象接收json格式数据  (老师上课演示)</span></span><br><span class="line"></span><br><span class="line"><span class="section">### <span class="strong">**特别注意**</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 前端传递过来的数据必须和我们的bean实体对象属性一致，若不一样，我们可以在前端再定义一个和实体类属性相同的json格式对象！！！</span></span><br><span class="line"></span><br><span class="line"><span class="section">### axios.post代码</span></span><br><span class="line"></span><br><span class="line"><span class="code">```js</span></span><br><span class="line"><span class="code">// 定义一个和自己实体类属性名一样的包含帐号密码的对象</span></span><br><span class="line"><span class="code">//根据自己的实体类来，我的实体类属性帐号密码为， userName, userPasswd. 在你的环境要根据你的来！！！！！</span></span><br><span class="line"><span class="code">let nameAndPwd = &#123;</span></span><br><span class="line"><span class="code">    userName : this.user.username,</span></span><br><span class="line"><span class="code">    userPasswd: this.user.password </span></span><br><span class="line"><span class="code">&#125;;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">// post请求</span></span><br><span class="line"><span class="code">this.$axios.post(&#x27;http://localhost:8090/register3&#x27;,this.data=nameAndPwd)</span></span><br><span class="line"><span class="code">    .then(res=&gt;&#123;</span></span><br><span class="line"><span class="code">    if(res.data.code==100)&#123;</span></span><br><span class="line"><span class="code">        this.$message(&#123;</span></span><br><span class="line"><span class="code">            showClose: true,</span></span><br><span class="line"><span class="code">            message: res.data.msg,</span></span><br><span class="line"><span class="code">            type: &quot;success&quot;</span></span><br><span class="line"><span class="code">        &#125;);</span></span><br><span class="line"><span class="code">        // this.$router.push(&quot;/&quot;);</span></span><br><span class="line"><span class="code">        alert(&quot;注册成功！&quot;)</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    else&#123;</span></span><br><span class="line"><span class="code">        console.log(res+&quot;error-----------------------------&quot;);</span></span><br><span class="line"><span class="code">        this.$message(&#123;</span></span><br><span class="line"><span class="code">            showClose: true,</span></span><br><span class="line"><span class="code">            message: res.data.msg,</span></span><br><span class="line"><span class="code">            type: &quot;error&quot;</span></span><br><span class="line"><span class="code">        &#125;);</span></span><br><span class="line"><span class="code">        // alert(&#x27;131 row error&#x27;);</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"><span class="code">```java</span></span><br><span class="line"><span class="code">//  使用对象接收必须保证表单属性 和 实体类的属性相同</span></span><br><span class="line"><span class="code">    @PostMapping(&quot;/register3&quot;)</span></span><br><span class="line"><span class="code">    public ResultVO signUp(@RequestBody User user)&#123;</span></span><br><span class="line"><span class="code">        System.out.println(&quot;register__3       :&quot;+user);</span></span><br><span class="line"><span class="code">        ResultVO insert = UserServiceImpl.Insert(user.getUserName(), user.getUserPasswd());</span></span><br><span class="line"><span class="code">        System.out.println(insert);</span></span><br><span class="line"><span class="code">        return insert;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 4.使用JSON.stringify()</span></span><br><span class="line"></span><br><span class="line"><span class="section">### JSON.stringify()作用: </span></span><br><span class="line"></span><br><span class="line">将json格式字符串化:  &#123;username : &quot;aaaa&quot;, password : &quot;1111&quot;&#125;    ===&gt;  &#123;&quot;username&quot; : &quot;aaaa&quot;, &quot;password&quot; : &quot;1111&quot;&#125;</span><br><span class="line"></span><br><span class="line">默认表单数据（json格式）：</span><br><span class="line"></span><br><span class="line">![<span class="string">image-20230114184055776</span>](<span class="link">/home/papillon/.config/Typora/typora-user-images/image-20230114184055776.png</span>)</span><br><span class="line"></span><br><span class="line">JSON.stringify() 格式化后：</span><br><span class="line"></span><br><span class="line">![<span class="string">image-20230114192453776</span>](<span class="link">/home/papillon/.config/Typora/typora-user-images/image-20230114192453776.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 原理：</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 将数据转化为字符串传到后端， 利用相关函数分割字符串并提取出来所需要的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**这种方法过于繁琐，且容易出错，这里不再进行演示.**</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## PS: 前三种方法我已经测试，均可正确运行，如果有哪里说的不对的地方，欢迎大家一起讨论，一起进步！</span></span><br></pre></td></tr></table></figure><h3 id="在浏览器控制台查看-vue对象"><a href="#在浏览器控制台查看-vue对象" class="headerlink" title="在浏览器控制台查看 vue对象"></a>在浏览器控制台查看 vue对象</h3><ul><li>使用 JSON.stringify(obj),  将json格式转化为字符串格式</li></ul><h2 id="后端-springboot"><a href="#后端-springboot" class="headerlink" title="后端 springboot"></a>后端 springboot</h2><h3 id="数据格式问题"><a href="#数据格式问题" class="headerlink" title="数据格式问题"></a>数据格式问题</h3><ul><li><p>@Responebody  将json格式转化为java对象</p><blockquote><p>可以在controllor类头部加入，也可以在方法参数对象前加入</p></blockquote></li></ul><h3 id="MAVEN依赖问题"><a href="#MAVEN依赖问题" class="headerlink" title="MAVEN依赖问题"></a>MAVEN依赖问题</h3><ul><li><p>当引入的依赖集成了其他的依赖和目前依赖发生冲突时，要将含有的集成依赖注释掉，用自己原本的依赖！</p><blockquote><p>例如引入tk.mybatis集成了mybatis, 要把tk.mybatis中集成的依赖注释掉</p></blockquote></li></ul><h3 id="关于tk-mybatis找不到实体类的问题"><a href="#关于tk-mybatis找不到实体类的问题" class="headerlink" title="关于tk.mybatis找不到实体类的问题"></a>关于tk.mybatis找不到实体类的问题</h3><blockquote><p> Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: tk.mybatis.mapper.MapperException: 无法获取实体类com.example.demo.entity.User对应的表名!]</p></blockquote><ul><li>还是依赖问题，要使用springboot starter 合适版本的mybatis，并要解决依赖冲突问题，将集成的依赖注释掉。(鼠标右键转到定义)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++随笔</title>
      <link href="/2024/02/19/CC++/"/>
      <url>/2024/02/19/CC++/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件的打开<br>fopen()：打开文件<br>文件的关闭<br>fclose()：关闭文件</p><p>文件的读写<br>fgetc()：读取一个字符   int fgetc ( FILE * stream );<br>fputc()：写入一个字符   int fputc( int c, FILE *stream );</p><p>fgets()：读取一个字符串 char * fgets ( char * str, int num, FILE * stream );<br>fputs()：写入一个字符串 int fputs( const char *string, FILE *stream );</p><p>fprintf()：写入格式化数据<br>fscanf()：格式化读取数据</p><p>fread()：读取数据   size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );<br>fwrite()：写入数据  size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );</p><p>文件状态检查<br>feof()：文件是否结束<br>ferror()：文件读&#x2F;写是否出错<br>clearerr()：清除文件错误标志<br>ftell()：文件指针的当前位置</p><p>文件指针定位<br>rewind()：把文件指针移到开始处<br>fseek()：重定位文件指针</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>数组指针 !&#x3D; 指针数组</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [] 优先级比 * 高</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **p = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">3</span>]</span><br><span class="line">    <span class="comment">//传参数</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">matrix_mutifly</span>(<span class="built_in">int</span> (*A)[<span class="number">10</span>], <span class="built_in">int</span> (*B)[<span class="number">10</span>], <span class="built_in">int</span> (*C)[<span class="number">10</span>])&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针与回调函数"><a href="#函数指针与回调函数" class="headerlink" title="函数指针与回调函数"></a>函数指针与回调函数</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="comment">// 函数指针初始化</span></span><br><span class="line"><span class="type">int</span> (*p_func)(<span class="type">int</span>) = func;</span><br><span class="line"><span class="comment">// 函数指针调用</span></span><br><span class="line">p_func(<span class="number">5</span>);              </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="type">int</span> (* p)(<span class="type">int</span>, <span class="type">int</span>) = &amp; max; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数字是: %d\n&quot;</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数-Callback-Function"><a href="#回调函数-Callback-Function" class="headerlink" title="回调函数 Callback Function"></a>回调函数 Callback Function</h2><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><p>回调函数通常是在特定的事件或条件发生时，由另外的一方调用的，用于对该事件或条件进行响应。其意义就在于解耦。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rfun_call</span><span class="params">(<span class="type">int</span> (*pfun)(<span class="type">unsigned</span>), <span class="type">unsigned</span> x)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> pfun(x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">populate_array</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">size_t</span> arraySize, <span class="type">int</span> (*getNextValue)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getNextRandomValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myarray[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">/* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/</span></span><br><span class="line">    populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><pre><code>fd_set 使用数组实现1.fd_size 有限制 1024 bitmap        fd【i】 = accept()    2.fdset不可重用，新的fd进来，重新创建    3.用户态和内核态拷贝产生开销    4.O(n)时间复杂度的轮询    成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0    具有超时时间</code></pre><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><pre><code>基于结构体存储fdstruct pollfd&#123;    int fd;    short events;    short revents; //可重用&#125;解决了select的1,2两点缺点</code></pre><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><pre><code>解决select的1，2，3，4不需要轮询，时间复杂度为O(1)epoll_create  创建一个白板 存放fd_eventsepoll_ctl 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上epoll_wait 通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符两种触发模式：    LT:水平触发        当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。    ET:边缘触发        和 LT 模式不同的是，通知之后进程必须立即处理事件。        下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，        因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</code></pre><h2 id="动态静态链接库"><a href="#动态静态链接库" class="headerlink" title="动态静态链接库"></a>动态静态链接库</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>静态库(.a): 在链接期间被应用程序直接链接进可执行文件</p></li><li><p>动态链接库(.so): 动态库还分为两种用法:<br>  a) 应用程序运行期间链接动态库，但是在编译期间声明动态库的存在，也就是说这种动态库必须在编译时对编译器可见，但编译器却不将此种库编译进可执行文件;</p><p>  b) 在运行期间，动态加载和卸载的库，使用动态加载方法加载。这种库的形式跟动态链接没有本质区别，区别是在调用时，是由用户程序决定何时链接的，而不是由系统链接器自动链接</p></li></ul><h2 id="编译库"><a href="#编译库" class="headerlink" title="编译库"></a>编译库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">动态库</span></span><br><span class="line">gcc -shared -fPIC xxx.c -o libxxx.so</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">静态库</span></span><br><span class="line">gcc -c xx.c -o xx.o  //生成math.o</span><br><span class="line">ar rc xx.a xx.o  //生成math.a</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libxxx.a</span></span><br><span class="line">g++  main.c -L. -lxxx -o main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">libxxx.so</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</span><br><span class="line">g++ -o main main.c -I. -L. -lxxx -stacic</span><br></pre></td></tr></table></figure><p>引入对应的头文件即可使用（相当于.a, .so 隐藏了具体实现）</p><p><strong>动态库使用方法</strong><br>    动态链接库的使用需要库的开发者提供生成的.lib文件和.dll文件。或者只提供dll文件。使用时只能使用dll中导出的函数，未导出的函数只能在dll内部使用。</p><pre><code>Dll的调用有显示连接和隐式连接两种：隐式连接需要三个东西，分别是*.h头文件，lib库（动态的）， DLL库；显示连接只需要.dll文件即可。</code></pre><h4 id="显式-动态-加载"><a href="#显式-动态-加载" class="headerlink" title="显式(动态)加载"></a>显式(动态)加载</h4><p>这种方式通过调用<a href="https://so.csdn.net/so/search?q=API%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">API函数</a>来完成对DLL的加载与卸载，能更加有效地使用内存，在编写大型应用程序时往往采用此方式。</p><p><strong>显式加载优点</strong></p><ul><li>灵活，可以在需要的时候用<code>LoadLibrary</code>进行加载，在不需要的时候用<code>FreeLibrary</code>进行卸载，这样可以不必占用内存。</li><li>可以在没有dll时候发现，而不致程序报错。</li><li>加载程序中有条件才运行的库。</li><li>热更新，在不停止程序的前提下进行更新。</li></ul><p><strong>显式加载缺点</strong></p><ul><li>复杂一些，需要显示获得函数地址。</li><li><code>dll</code>没有对应的<code>lib</code>文件，此时只能进行动态加载。</li></ul><p><strong>加载方法</strong></p><ul><li>使用Windows API函数Load Library将<code>DLL</code>模块映像到进程的内存空间，对<code>DLL</code>模块进行动态加载。</li><li>使用<code>GetProcAddress</code>函数得到要调用<code>DLL</code>中的函数的指针。</li><li>不用<code>DLL</code>时，用<code>FreeLibrary</code>函数或者<code>AfxFreeLibrary</code>函数从进程的地址空间显式卸载<code>DLL</code>。</li></ul><ol><li>动态(显式)调用，只需要<code>xxx.dll</code><br><strong>Windoiws环境</strong>：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DynamicUse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 运行时加载DLL库,静态加载</span></span><br><span class="line">HMODULE <span class="keyword">module</span> = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;DLLTest1.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;加载DLLTest1.dll动态库失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*AddFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 定义函数指针类型</span></span><br><span class="line">AddFunc add; </span><br><span class="line">    <span class="comment">// 导出函数地址</span></span><br><span class="line">add = (AddFunc)<span class="built_in">GetProcAddress</span>(<span class="keyword">module</span>, <span class="string">&quot;add&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum  = <span class="built_in">add</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;动态调用，sum = %d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong><code>linux</code>环境</strong>: Linux中的<code>so</code>库<strong>实现库的动态加载。最终链接时，使用</strong><code>-ldl</code>**。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">dlerror</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">dlsym</span><span class="params">(<span class="type">void</span> *handle,<span class="type">const</span> <span class="type">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>   <span class="title">dlclose</span><span class="params">(<span class="type">void</span> *handle)</span></span>;</span><br><span class="line"> </span><br><span class="line">Link with -ldl</span><br></pre></td></tr></table></figure><p><strong>编译链接</strong><br><code>gcc dmain.c -ldl -o main</code></p><ol start="2"><li>静态(隐式)调用,还需要<code>xxx.h</code><br><strong>windows环境</strong>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 先将lib与dll导入项目</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;DLLTest1.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态调用DLL库</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StaticUse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;静态调用，sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p><strong><code>linux</code>环境</strong>:<br>设置<code>LD_LIBRARY_PATH</code> 参数指定路径，否则无法运行可执行程序<br><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</code> &#x2F;&#x2F; .表示当前目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -L./ -lmath -o main</span><br></pre></td></tr></table></figure><h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><h3 id="nm命令"><a href="#nm命令" class="headerlink" title="nm命令"></a>nm命令</h3><p>有时候可能需要查看一个库中到底有哪些函数，<strong>nm****命令</strong>可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：</p><p>-  一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；</p><p>-  一种是库中定义的函数，用T表示，这是最常见的；</p><p>-  一种是所谓的弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。</p><p><code>$nm libhello.a</code></p><h3 id="ldd命令"><a href="#ldd命令" class="headerlink" title="ldd命令"></a>ldd命令</h3><p><strong>ldd****命令可以查看一个可执行程序依赖的共享库</strong>，例如我们编写的四则运算动态库依赖下面这些库：</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">单例模式：确保一个类只有一个实例，并提供全局访问点。</span><br><span class="line">工厂模式：通过工厂方法创建对象，而无需直接使用 new 关键字。</span><br><span class="line">抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</span><br><span class="line">代理模式：为其他对象提供一种代理以控制对这个对象的访问。</span><br><span class="line">观察者模式：定义对象间的一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知。</span><br><span class="line">装饰器模式：动态地给一个对象增加一些额外的职责，就像给一个人穿上不同的衣服一样可以改变他的外表。</span><br><span class="line">模板方法模式：定义一个操作中算法的骨架，将一些步骤延迟到子类中去实现。</span><br><span class="line">策略模式：定义了一系列的算法，并将每个算法封装起来，使它们可以相互替换。</span><br><span class="line">迭代器模式：提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</span><br><span class="line">适配器模式：将一个类的接口转换成客户希望的另外一个接口。</span><br></pre></td></tr></table></figure><h2 id="PIMPL"><a href="#PIMPL" class="headerlink" title="PIMPL"></a>PIMPL</h2><blockquote><p>PIMPL（Pointer to Implementation）是一种设计模式，用于减少类之间的依赖关系和编译时间。它的基本思想是将类的实现细节封装在一个独立的类中，然后将这个类的指针作为类的成员变量来使用，从而达到降低编译时耦合度的目的。</p></blockquote><blockquote><p>具体来说，PIMPL 模式将公共接口与私有实现分离开来。公共接口是一个完整的类定义，而私有实现则是由一个独立的类进行实现，这个独立的类被称为 PIMPL 类。PIMPL 类只能在类的实现文件中引用，在类的头文件中并不可见。这样做可以有效地隐藏内部实现细节，并且在修改实现时不会影响用户代码的编译。</p></blockquote><blockquote><p>使用 PIMPL 模式可以避免头文件的相互包含，从而减少编译时间。此外，当需要修改类的实现时，只需要修改 PIMPL 类的定义，而不需要重新编译使用这个类的客户端代码。这使得代码的维护更加容易，也提高了代码的可重用性。</p></blockquote><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[&quot;socket() &lt;br&gt; 1. 创建流式socket&quot;] --&gt; B[&quot;connnect() &lt;br&gt; 2. 向服务器发起连接请求&quot;]</span><br><span class="line"> B --&gt; C[&quot;send()/recv() &lt;br&gt; 3. 发送/接收数据&quot;]</span><br><span class="line"> C --&gt; D[&quot;close() &lt;br&gt; 4. 关闭socket连接，释放资源&quot;]</span><br><span class="line"> M[客户端]</span><br></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[&quot;socket() &lt;br&gt; 1. 创建流式socket&quot;] --&gt; B[&quot;bind() &lt;br&gt; 2. 指定用于通讯的ip地址和端口&quot;]</span><br><span class="line">B --&gt; C[&quot;listen() &lt;br&gt; 3. 把socket设置为监听模式&quot;]</span><br><span class="line">C --&gt; D[&quot;accept() &lt;br&gt; 4. 接受客户端的连接&quot;]</span><br><span class="line">D --&gt; E[&quot;recv()/send() &lt;br&gt; 5. 接收/发送数据&quot;]</span><br><span class="line">E --&gt; F[&quot;close() &lt;br&gt; 6. 关闭socket连接，释放资源&quot;]</span><br></pre></td></tr></table></figure><h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><p>C++ 是一种面向对象的编程语言，它具有以下特性：</p><ol><li>面向对象：C++ 支持面向对象的编程范式，包括封装、继承和多态。</li><li>泛型编程：C++ 支持泛型编程，可以使用模板来实现通用的数据类型和算法。</li><li>高效性：C++ 是一种高效的语言，它可以直接操作内存，而不需要通过虚拟机或解释器来执行代码。</li><li>多重继承：C++ 支持多重继承，可以从多个基类中继承属性和方法。</li><li>强类型：C++ 是一种强类型语言，可以在编译时检查类型错误。</li><li>高级内存管理：C++ 允许程序员直接管理内存，包括动态分配和释放内存。</li><li>运算符重载：C++ 允许程序员重载运算符，可以自定义对象之间的运算。</li><li>内联函数：C++ 支持内联函数，可以将函数的代码直接插入到调用它的地方，提高执行效率。</li><li>异常处理：C++ 支持异常处理，可以在程序出现异常时进行处理。</li><li>标准库：C++ 标准库提供了丰富的函数和类，包括容器、算法、输入输出和字符串处理等。</li></ol><h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><h3 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h3><p><code>x++</code> 是右值；<code>++x</code> 是左值。<br>笼统区分左右值是看在等号左边还是右边。但凡能取地址就是左值；通常字面量是一个右值，字符串字面量除外（<code>auto p = &amp;&quot;hello&quot;;</code>,其能取地址）； </p><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p><code>int a = 0; int &amp;b = a;</code></p><ol><li>常量左值引用既可以接收左值又可以接收右值。但无法修改内容，强制类型转换除外。</li><li></li></ol><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p><code>int &amp;&amp;x = 1;</code><br>作用: 延长右值的声明周期，减少对象的复制，提升程序性能。</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>移动构造器，只有指针的替换，没有内存的申请和释放。形参要使用右值引用，因为资源被转移而不会发生深拷贝。<br>移动构造器要加<code>noexcept</code>保证函数发生异常时终止，因为移动时发生异常会造成源对象与目标对象都不完整的情况。</p><h3 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[expression表达式 ] --&gt; B[glvalue泛左值]</span><br><span class="line">A --&gt; C[rvalue右值]</span><br><span class="line">B --&gt; D[lvalue左值]</span><br><span class="line">B --&gt; E[xvalue将亡值]</span><br><span class="line">C --&gt; E</span><br><span class="line">C --&gt; F[prvalue纯右值]</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>需要引入相应的头文件<br>1 vector<code>&lt;int&gt;</code>vec;&#x2F;&#x2F;定义vector,常用<br>2 list<code>&lt;int&gt;</code>lis;<br>3 deque<code>&lt;int&gt;</code>deq;<br>4 stack<code>&lt;int&gt;</code>sta;&#x2F;&#x2F;定义栈,常用<br>5 queue<code>&lt;int&gt;</code>que;&#x2F;&#x2F;定义栈,常用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector的定义</span></span><br><span class="line">vector                   创建一个空的vector。</span><br><span class="line"><span class="function">vector  <span class="title">c1</span><span class="params">(c2)</span>           复制一个vector</span></span><br><span class="line"><span class="function">vector  <span class="title">c</span><span class="params">(n)</span>             创建一个vector，含有n个数据，数据均已缺省构造产生</span></span><br><span class="line"><span class="function">vector  <span class="title">c</span><span class="params">(n, elem)</span>   　　 创建一个含有n个elem拷贝的vector</span></span><br><span class="line"><span class="function">vector  <span class="title">c</span><span class="params">(beg,end)</span>       创建一个含有n个elem拷贝的vector</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//vector的操作</span></span></span><br><span class="line"><span class="function">c.<span class="title">assign</span><span class="params">(beg,end)</span>        将 [beg</span>; end)区间中的数据赋值给c。</span><br><span class="line">c.<span class="built_in">assign</span>(n,elem)　　　　  将n个elem的拷贝赋值给c。</span><br><span class="line">c.<span class="built_in">at</span>(idx)　　　　　　　　  传回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">c.<span class="built_in">back</span>()                 传回最后一个数据，不检查这个数据是否存在。</span><br><span class="line">c.<span class="built_in">begin</span>()    　　　　　　　传回迭代器中的第一个数据地址。</span><br><span class="line">c.<span class="built_in">capacity</span>()  　　　　　　 返回容器中数据个数。</span><br><span class="line">c.<span class="built_in">clear</span>()     　　　　　　 移除容器中所有数据。</span><br><span class="line">c.<span class="built_in">empty</span>()     　　　　　　 判断容器是否为空。</span><br><span class="line">c.<span class="built_in">end</span>()       　　　　　　 指向迭代器中末端元素的下一个，指向一个不存在元素。</span><br><span class="line">c.<span class="built_in">erase</span>(pos) 　　　　　　  删除pos位置的数据，传回下一个数据的位置。</span><br><span class="line">c.<span class="built_in">erase</span>(beg,end)  　　 　 删除[beg,end)区间的数据，传回下一个数据的位置。</span><br><span class="line">c.<span class="built_in">front</span>()     　　　　　　 传回第一个数据。</span><br><span class="line">get_allocator　　　　　　  使用构造函数返回一个拷贝。</span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem)   　　 在pos位置插入一个elem拷贝，传回新数据位置。</span><br><span class="line">c.<span class="built_in">insert</span>(pos,n,elem)  　　在pos位置插入n个elem数据。无返回值。</span><br><span class="line">c.<span class="built_in">insert</span>(pos,beg,end) 　　在pos位置插入在[beg,end)区间的数据。无返回值。</span><br><span class="line">c.<span class="built_in">max_size</span>()       　　   返回容器中最大数据的数量。</span><br><span class="line">c.<span class="built_in">pop_back</span>()      　　　　 删除最后一个数据。</span><br><span class="line">c.<span class="built_in">push_back</span>(elem) 　　    在尾部加入一个数据。</span><br><span class="line">c.<span class="built_in">rbegin</span>()         　　　　传回一个逆向队列的第一个数据。</span><br><span class="line">c.<span class="built_in">rend</span>()           　　　　传回一个逆向队列的最后一个数据的下一个位置。</span><br><span class="line">c.<span class="built_in">resize</span>(num)     　　　　 重新指定队列的长度。</span><br><span class="line">c.<span class="built_in">reserve</span>()       　　　　 保留适当的容量。</span><br><span class="line">c.<span class="built_in">size</span>()             　　 返回容器中实际数据的个数。</span><br><span class="line">c1.<span class="built_in">swap</span>(c2)</span><br><span class="line"><span class="built_in">swap</span>(c1,c2)      　　　　　将c1和c2元素互换。同上操作。</span><br><span class="line"><span class="keyword">operator</span>[]       　　　　　返回容器中指定位置的一个引用。</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="inline-与-static"><a href="#inline-与-static" class="headerlink" title="inline 与 static"></a>inline 与 static</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">非类的成员函数以及成员变量</span><br><span class="line">inline修饰的函数或变量（c++17开始可以修饰变量）在全局保留一份；</span><br><span class="line"></span><br><span class="line">static修饰的函数或者变量会在各自的编译单元都保留一份；</span><br><span class="line"></span><br><span class="line">static函数的局部static变量也会有多份，inline函数的static变量只有一份;</span><br><span class="line"></span><br><span class="line">static inline 修饰的函数或者变量与static单独修饰的效果一致；</span><br><span class="line"></span><br><span class="line">inline 不能修饰局部变量；</span><br><span class="line"></span><br><span class="line">有关类的成员函数以及成员变量</span><br><span class="line">类的非const静态成员变量初始化，C++ 17可以通过static inline 在类内直接初始化，C++17之前必须在类外初始化（const static 修饰的变量也可以类内初始化，这个在之前也是可以的）；</span><br><span class="line"></span><br><span class="line">C++17之后，类的静态成员变量在类内通过static声明，在类外（但是在头文件中）初始化不加inline的话可能会导致重定义从而出现链接错误，而加了inline 就不会出错，类似有无inline修饰的全局函数；</span><br><span class="line"></span><br><span class="line">C++ 17之前必须在.cpp中初始化静态成员才不会出现重定义的错误，在.h中初始化还是会导致重定义错误，因为C++17之前的标准不支持inline修饰类的静态成员变量；</span><br><span class="line"></span><br><span class="line">类中的函数其实可以认为是都隐式加了inline的，因为类中的所有函数在全局都只有一份，而有无static修饰只是限制该函数对类数据成员的使用（类的static函数只能使用static成员变量，类的普通成员函数可以使用所有的成员变量 ）；</span><br><span class="line"></span><br><span class="line"> inline使用场景：(1)、可以使用inline函数完全取代表达式形式的宏定义；(2)、内联函数一般只会用在函数内容非常简单的时候，这是因为，内联函数的代码会在任何调用它的地方展开，如果函数太复杂，代码膨胀带来的恶果很可能会大于效率的提高带来的益处。</span><br><span class="line"> </span><br><span class="line"> 内联函数可减少cpu的系统开销，并且程序的整体速度将加快，但当内联函数很大时，会有相反的作用，因此一般比较小的函数才使用内联函数．</span><br><span class="line"> </span><br><span class="line">  内联是一种对编译器的请求，下面这些情况会阻止编译器服从这项请求：如果函数中包含有循环，switch或goto语句，递归函数，含有static的函数．</span><br><span class="line">  </span><br><span class="line">   static inline，静态内联函数，它不使用函数调用，直接将汇编代码插入在调用该函数处。</span><br><span class="line">   static inline，可以把它认为是一个static的函数，加上了inline的属性。static inline函数和static函数一样，其定义的范围是local的，即可以在程序内有多个不同的定义(只要不位于同一个文件内即可)。</span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、纯虚函数声明如下： <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funtion1</span><span class="params">()</span></span>=<span class="number">0</span>; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、虚函数声明如下：<span class="function"><span class="keyword">virtual</span> ReturnType <span class="title">FunctionName</span><span class="params">(Parameter)</span> 虚函数必须实现，如果不实现，编译器将报错.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5、虚函数是C++中用于实现多态<span class="params">(polymorphism)</span>的机制。核心理念就是通过基类访问派生类定义的函数。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</span></span><br></pre></td></tr></table></figure><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture-list] (parameter-list) -&gt; <span class="keyword">return</span>-type &#123; function-body &#125;</span><br><span class="line">[] &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式的函数体</span></span><br><span class="line">    <span class="comment">// 无参数，无返回值</span></span><br><span class="line">&#125;</span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式的函数体</span></span><br><span class="line">    <span class="comment">// 参数为 a 和 b，无返回值</span></span><br><span class="line">&#125;</span><br><span class="line">[](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// lambda 表达式的函数体</span></span><br><span class="line">    <span class="comment">// 参数为 a 和 b，返回值为 int 类型</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">[]中为空表示不捕获外部变量</span><br><span class="line">[=] 按值捕获所有外部变量</span><br><span class="line">[&amp;] 按引用捕获所有外部变量</span><br><span class="line">[x,&amp;y] 按值捕获x，按引用捕获y</span><br></pre></td></tr></table></figure><h2 id="函数隐藏，函数重载，函数重写，多态性"><a href="#函数隐藏，函数重载，函数重写，多态性" class="headerlink" title="函数隐藏，函数重载，函数重写，多态性"></a>函数隐藏，函数重载，函数重写，多态性</h2><h3 id="函数隐藏-重定义"><a href="#函数隐藏-重定义" class="headerlink" title="函数隐藏&#x2F;重定义"></a>函数隐藏&#x2F;重定义</h3><p>基类和派生类函数名一致但参数列表无所谓的非虚函数，派生类默认访问派生类函数，也可以通过添加类限定符访问基类函数，例如: <code>B b; b.A::show();</code></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个类中，函数名一致，但参数列表不一致，可看作是两个独立的函数。</p><h3 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h3><p>基类使用 virtual 关键字修饰成员函数，派生类重写此函数，函数名和参数列表均一致。</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>派生类存在函数重写，即重写了virtual修饰的函数，且存在基类指针指向派生类对象的情况</p><p> a编译时多态性：通过重载函数实现 。<br> b运行时多态性：通过虚函数实现。</p><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>基类必须存在虚函数才能使用，其本质是查询虚函数表。</p><p>不能保证转换是否安全，但可以给出结果，指针或nullptr</p><h2 id="指针强行转换"><a href="#指针强行转换" class="headerlink" title="指针强行转换"></a>指针强行转换</h2><ol><li>静态类型检查失效：在编译时，编译器只能检查指针的静态类型，而不能检查指针所指向对象的动态类型。因此，如果将一个父类指针强制转换为子类指针，但实际指向的对象不是子类对象，那么在运行时可能会发生未定义行为，如访问非法内存地址、引起段错误等。</li><li>数据截断：由于子类对象可能比父类对象更大，因此将子类指针强制转换为父类指针可能会导致数据截断。例如，如果一个子类对象有一个额外的成员变量，但将其强制转换为父类指针，那么访问该成员变量可能会导致未定义行为。</li><li>对象切片：当将子类对象赋值给父类对象时，只会复制父类部分的成员变量，而子类部分的成员变量将被忽略。这种现象被称为“对象切片”，可能会导致程序错误。</li></ol><p>因此，应该避免在 C++ 中进行父类和子类指针之间的强制类型转换，或者在进行转换之前进行动态类型检查，以确保指针所指向的对象的动态类型与转换后的类型相同。</p><h2 id="type-type-info"><a href="#type-type-info" class="headerlink" title="type &amp; type_info"></a>type &amp; type_info</h2><p>typeid晕眩符返回type_info类的引用.(头文件 <typeinfo>)</p><p>重载了 <code>==</code> 和<code>!==</code>运算符，用于类型的比较</p><p>可以用在多态场景，在运行阶段识别对象的数据类型</p><h2 id="泛编程"><a href="#泛编程" class="headerlink" title="泛编程"></a>泛编程</h2><p>自动推导类型，函数模板，类模板</p><h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>自动推导类型</p><p>用途如下：</p><blockquote><p>函数指针</p><p>模板中声明依赖模板参数的变量</p><p>模板中依赖模板参数的返回值</p><p>lambda表达式</p></blockquote><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>关键字可以用 typename 和 class，函数模板用typename，类模板用class</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br></pre></td></tr></table></figure><p>不能为虚函数和析构函数使用模板</p><p>使用函数模板时，尽量显示制定类型，没用到T时，必须明确数据类型</p><p>函数模板的具体化（尖括号内不写类型）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(参数列表)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级</p><p>具体化模板优先于常规模板，普通函数优先于具体化模板。</p><p>如果希望使用函数模板，可以用空模板参数<code>Swap&lt;&gt;(a,b)</code>强制使用函数模板</p><p>如果函数模板能产生更好地匹配，将优先于非函数模板</p><p>&#x3D;&#x3D;普通函数模板的声明和定义都要写在头文件中，而具体化模板可以分开写&#x3D;&#x3D;</p><h4 id="decltype推导类型"><a href="#decltype推导类型" class="headerlink" title="decltype推导类型"></a>decltype推导类型</h4><p><code>decltype(expression) var</code></p><blockquote><p>short a &#x3D; 5;</p><p>decltype(a) da;  da-&gt;short</p><p>decltype((a)) da&#x3D;a; (引用要初始化)da-&gt;short &amp;</p><p>decltype(++a) da; da-&gt;short&amp;</p><p>decltype(func()) da; da-&gt;func的返回值类型</p><p>decltype(func) da; da-&gt;int da(), 即func的函数类型</p><p>decltype((func)) da &#x3D; func;(引用要初始化) da-&gt;int (&amp;da)(), 即函数的引用类型 </p><p>decltype(func) *da &#x3D; func;  da-&gt; int (*da)(), 即函数指针类型;</p></blockquote><h4 id="decltype-auto-区别"><a href="#decltype-auto-区别" class="headerlink" title="decltype &amp; auto 区别"></a>decltype &amp; auto 区别</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) da;<span class="comment">// 不会执行函数</span></span><br><span class="line"><span class="keyword">auto</span> db = <span class="built_in">func</span>();<span class="comment">// 会执行函数，因为需要推导表达式</span></span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="调用DLL文件"><a href="#调用DLL文件" class="headerlink" title="调用DLL文件"></a>调用DLL文件</h2><p>在C++中调用DLL文件，可以使用以下步骤：</p><ol><li>在C++代码中包含Windows.h头文件。</li><li>使用LoadLibrary函数加载DLL文件。该函数返回一个句柄，可以用于后续的函数调用。</li><li>使用GetProcAddress函数获取DLL文件中的函数地址。该函数需要传递DLL文件的句柄和函数名。</li><li>将获取的函数地址转换为函数指针，并调用该函数。可以使用typedef来定义函数指针类型，以便更方便地调用函数。</li></ol><p>下面是一个简单的示例代码，演示如何在C++中调用DLL文件中的函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*AddFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">// 定义函数指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HINSTANCE hDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;MyDll.dll&quot;</span>); <span class="comment">// 加载DLL文件</span></span><br><span class="line">    <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to load DLL file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddFunc addFunc = (AddFunc)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;Add&quot;</span>); <span class="comment">// 获取函数地址</span></span><br><span class="line">    <span class="keyword">if</span> (addFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to get function address.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">addFunc</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hDll); <span class="comment">// 卸载DLL文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，我们首先使用LoadLibrary函数加载了一个名为MyDll.dll的DLL文件。然后使用GetProcAddress函数获取了该文件中名为Add的函数的地址，并将其转换为函数指针类型AddFunc。最后，我们调用了该函数并输出了结果。最后使用FreeLibrary函数卸载了DLL文件。</p><h2 id="文件操作-1"><a href="#文件操作-1" class="headerlink" title="文件操作"></a>文件操作</h2><p>输出流：ostream (output stream)<br>输出流：istream (input stream)<br>输入输出流：iostream<br>写操作（输出）的文件类：ofstream<br>读操作（输入）的文件类：ifstream<br>可同时读写操作的文件类：fstream (file stream)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对文件的读取示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];                       <span class="comment">//定义一个数组，用来存放字符</span></span><br><span class="line">    <span class="function">ifstream <span class="title">examplefile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;    <span class="comment">//声明一个对象与要读的文件联系</span></span><br><span class="line">    <span class="keyword">if</span> (! examplefile.<span class="built_in">is_open</span>())            <span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error opening file&quot;</span>; <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!examplefile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        examplefile.<span class="built_in">getline</span>(buffer,<span class="number">100</span>);</span><br><span class="line">        cout&lt;&lt;buffer&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><p>ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)，用于关闭C&#x2F;C++的标准流的同步，还将cin,cout与cerr分离，避免cin，cout同步问题</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>如果希望在最终读入的字符串中保留空格，可以使用getline函数<br>getline(cin , s1);</p><h3 id="1-字符串构造函数"><a href="#1-字符串构造函数" class="headerlink" title="1.字符串构造函数"></a>1.字符串构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str1;               <span class="comment">//生成空字符串</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;  <span class="comment">//生成&quot;1234456789&quot;的复制品</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot;</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;012345&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为&quot;01234&quot;</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;       <span class="comment">//结果为&quot;11111&quot;</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为&quot;3456789&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-string大小和容量"><a href="#2-string大小和容量" class="headerlink" title="2.string大小和容量"></a>2.string大小和容量</h3><ol><li>size()和length()：返回string对象的字符个数，他们执行效果相同。</li><li>max_size()：返回string对象最多包含的字符数，超出会抛出length_error异常</li><li>capacity()：重新分配内存之前，string对象能包含的最大字符数</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;1234567&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;      <span class="comment">//7</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;length=&quot;</span> &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;  <span class="comment">//7</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;max_size=&quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl; <span class="comment">// 4294967294</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; s.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h3 id="3-string的字符串比较"><a href="#3-string的字符串比较" class="headerlink" title="3.string的字符串比较"></a>3.string的字符串比较</h3><ol><li>C ++字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小(前面减后面)<br>同时，string (“aaaa”) &lt; string(“aaaaa”)。</li><li>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。<br>他返回一个整数来表示比较结果，返回值意义如下：0：相等 1：大于 -1：小于 (A的ASCII码是65，a的ASCII码是97)</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">A</span><span class="params">(<span class="string">&quot;aBcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">B</span><span class="params">(<span class="string">&quot;Abcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">C</span><span class="params">(<span class="string">&quot;123456&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">D</span><span class="params">(<span class="string">&quot;123dfg&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aBcd&quot; 和 &quot;Abcd&quot;比较------ a &gt; A</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.compare(B)：&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(B)&lt;&lt; endl;                          <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cd&quot; 和 &quot;Abcd&quot;比较------- c &gt; A</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B):&quot;</span> &lt;&lt;A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B)&lt;&lt; endl;                <span class="comment">// 结果：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cd&quot; 和 &quot;cd&quot;比较 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A.compare(2, 3, B, 2, 3):&quot;</span> &lt;&lt; A.<span class="built_in">compare</span>(<span class="number">2</span>, <span class="number">3</span>, B, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 结果：0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由结果看出来：0表示下标，3表示长度</span></span><br><span class="line"><span class="comment">// &quot;123&quot; 和 &quot;123&quot;比较 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C.compare(0, 3, D, 0, 3)&quot;</span> &lt;&lt;C.<span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">3</span>, D, <span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl;    <span class="comment">// 结果：0</span></span><br></pre></td></tr></table></figure><h3 id="4-string的插入"><a href="#4-string的插入" class="headerlink" title="4.string的插入"></a>4.string的插入</h3><ol><li>push_back() : 在尾部插入字符</li><li>insert(pos, char) : 在 pos前插入字符串char</li></ol><h3 id="5-string字符串拼接"><a href="#5-string字符串拼接" class="headerlink" title="5.string字符串拼接"></a>5.string字符串拼接</h3><ol><li>append() : 尾部加入字符串</li><li><ul><li>: 尾部加入字符串</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：append()</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">s1.<span class="built_in">append</span>(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s1:&quot;</span>&lt;&lt;s1&lt;&lt;endl; <span class="comment">// s1:abcdef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：+ 操作符</span></span><br><span class="line">string s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">/*s2 += &quot;def&quot;;*/</span></span><br><span class="line">string s3 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">s2 += s3.<span class="built_in">c_str</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s2:&quot;</span>&lt;&lt;s2&lt;&lt;endl; <span class="comment">// s2:abcdef</span></span><br></pre></td></tr></table></figure><h3 id="6-string遍历"><a href="#6-string遍历" class="headerlink" title="6.string遍历"></a>6.string遍历</h3><p>迭代器 或者 下标法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string::iterator iter = s1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>( ; iter &lt; s1.<span class="built_in">end</span>() ; iter++)</span><br><span class="line">&#123;</span><br><span class="line">   cout&lt;&lt;*iter;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>str[i] &#x2F; str.at(i);</p><h3 id="7-string的删除"><a href="#7-string的删除" class="headerlink" title="7.string的删除"></a>7.string的删除</h3><ol><li>iterator erase(iterator p);&#x2F;&#x2F;删除字符串中p所指的字符</li><li>iterator erase(iterator first, iterator last);&#x2F;&#x2F;删除字符串中迭代器区间 <code>[first,last)</code>上所有字符  左闭右开</li><li>string&amp; erase(size_t pos &#x3D; 0, size_t len &#x3D; npos);&#x2F;&#x2F;删除字符串中从索引位置pos开始的len个字符</li><li>void clear();&#x2F;&#x2F;删除字符串中所有字符</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// s1.erase(s1.begin()+1);              // 结果：13456789</span></span><br><span class="line"><span class="comment">// s1.erase(s1.begin()+1,s1.end()-2);   // 结果：189</span></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">1</span>,<span class="number">6</span>);                       <span class="comment">// 结果：189</span></span><br><span class="line">string::iterator iter = s1.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><h3 id="8-string的字符替换"><a href="#8-string的字符替换" class="headerlink" title="8.string的字符替换"></a>8.string的字符替换</h3><ol><li>string&amp; replace(size_t pos, size_t n, const char *s);&#x2F;&#x2F;将当前字符串从pos索引开始的n个字符，替换成字符串s</li><li>string&amp; replace(size_t pos, size_t n, size_t n1, char c); &#x2F;&#x2F;将当前字符串从pos索引开始的n个字符，替换成n1个字符c</li><li>string&amp; replace(iterator i1, iterator i2, const char* s);&#x2F;&#x2F;将当前字符串 <code>[i1,i2)</code>区间中的字符串替换为字符串s</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello,world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s1.<span class="built_in">size</span>()&lt;&lt;endl;                     <span class="comment">// 结果：12</span></span><br><span class="line">s1.<span class="built_in">replace</span>(s1.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);           <span class="comment">// 结果：hello,world.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的6表示下标  5表示长度</span></span><br><span class="line">s1.<span class="built_in">replace</span>(<span class="number">6</span>,<span class="number">5</span>,<span class="string">&quot;girl&quot;</span>);                    <span class="comment">// 结果：hello,girl.</span></span><br><span class="line"><span class="comment">// s1.begin(),s1.begin()+5 是左闭右开区间</span></span><br><span class="line">s1.<span class="built_in">replace</span>(s1.<span class="built_in">begin</span>(),s1.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&quot;boy&quot;</span>); <span class="comment">// 结果：boy,girl.</span></span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="9-string大小写替换"><a href="#9-string大小写替换" class="headerlink" title="9.string大小写替换"></a>9.string大小写替换</h3><ol><li>tolower(); toupper();</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">   s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>STL的transform算法配合的toupper和tolower</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line">string result;</span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);</span><br></pre></td></tr></table></figure><h3 id="10-string的查找"><a href="#10-string的查找" class="headerlink" title="10.string的查找"></a>10.string的查找</h3><ol><li><p>size_t find (constchar* s, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串</p><p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串</p></li><li><p>size_t find (charc, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</p><p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_t rfind (constchar* s, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</p><p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</p></li><li><p>size_t rfind (charc, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</p><p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_tfind_first_of (const char* s, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_tfind_first_not_of (const char* s, size_t pos &#x3D; 0) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_t find_last_of(const char* s, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><p>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_tfind_last_not_of (const char* s, size_t pos &#x3D; npos) const;<br>&#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串查找-----找到后返回首字母在字符串中的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 查找一个字符串</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;        <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;i&#x27;</span>,<span class="number">6</span>) &lt;&lt; endl;            <span class="comment">// 结果是：11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;       <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从字符串的末尾开始查找字符</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&#x27;i&#x27;</span>) &lt;&lt; endl;             <span class="comment">// 结果是：18-------因为是从末尾开始查找，所以返回第一次找到的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 在该字符串中查找第一个属于字符串s的字符</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_first_of</span>(<span class="string">&quot;13br98&quot;</span>) &lt;&lt; endl;  <span class="comment">// 结果是：4---b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl; <span class="comment">// 结果是：4</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;  <span class="comment">// 结果是：9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_last_of</span>(<span class="string">&quot;13r98&quot;</span>) &lt;&lt; endl;               <span class="comment">// 结果是：19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;teac&quot;</span>) &lt;&lt; endl;            <span class="comment">// 结果是：21</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-string的排序-sort-s-begin-s-end"><a href="#11-string的排序-sort-s-begin-s-end" class="headerlink" title="11.string的排序 sort(s.begin(),s.end())"></a>11.string的排序 sort(s.begin(),s.end())</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;cdefba&quot;</span>;</span><br><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s:&quot;</span>&lt;&lt;s&lt;&lt;endl;     <span class="comment">// 结果：abcdef</span></span><br></pre></td></tr></table></figure><h3 id="12-string的分割-截取-strtok-substr"><a href="#12-string的分割-截取-strtok-substr" class="headerlink" title="12.string的分割&#x2F;截取 strtok() &#x2F; substr()"></a>12.string的分割&#x2F;截取 strtok() &#x2F; substr()</h3><ol><li>strtok()</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;I,am,a,student; hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *split = <span class="string">&quot;,; !&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p2 = <span class="built_in">strtok</span>(str,split);</span><br></pre></td></tr></table></figure><ol start="2"><li>substr()</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s1.<span class="built_in">substr</span>(<span class="number">2</span>,<span class="number">5</span>); <span class="comment">// 结果：23456-----参数5表示：截取的字符串的长度</span></span><br></pre></td></tr></table></figure><h3 id="13-string-char-转换"><a href="#13-string-char-转换" class="headerlink" title="13. string char 转换"></a>13. string char 转换</h3><p>将数值 val 转换为 string 。val 可以是任何算术类型（int、浮点型等）。<br><code>string s = to_string(val)</code></p><h3 id="14-string-reverse反转"><a href="#14-string-reverse反转" class="headerlink" title="14. string reverse反转"></a>14. string reverse反转</h3><p>reverse(str.begin(),str.end());<br>reverse还可用于数组 reverse(array, array+arrat.lenth())<br>STL任何容器都可以。</p><h3 id="sscanf-const-char-str-const-char-format-…"><a href="#sscanf-const-char-str-const-char-format-…" class="headerlink" title="sscanf(const char *str, const char *format, …);"></a>sscanf(const char *str, const char *format, …);</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> converted = <span class="built_in">sscanf</span>(<span class="string">&quot;20191103&quot;</span>, <span class="string">&quot;%04d%02d%02d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;converted=%d, year=%d, month=%d, day=%d/n&quot;</span>, converted, year, month, day);</span><br></pre></td></tr></table></figure><h3 id="string-转-time-t"><a href="#string-转-time-t" class="headerlink" title="string 转 time_t"></a>string 转 time_t</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux下存储时间常见的有两种存储方式，一个是从1970年到现在经过了多少秒，一个是用一个结构来分别存储年月日时分秒的。</span></span><br><span class="line"><span class="comment">//time_t 这种类型就是用来存储从1970年到现在经过了多少秒，要想更精确一点，可以用结构struct timeval，它精确到微妙。</span></span><br><span class="line"><span class="comment">// 从1970-1-1 00：00：00 过了多少秒</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">time_t</span>&#123;</span><br><span class="line">   <span class="type">long</span> t_sec;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> tv_sec; <span class="comment">/*秒*/</span></span><br><span class="line">    <span class="type">long</span> tv_usec; <span class="comment">/*微秒*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;  <span class="comment">/*秒，正常范围0-59， 但允许至61*/</span></span><br><span class="line">    <span class="type">int</span> tm_min;  <span class="comment">/*分钟，0-59*/</span></span><br><span class="line">    <span class="type">int</span> tm_hour; <span class="comment">/*小时， 0-23*/</span></span><br><span class="line">    <span class="type">int</span> tm_mday; <span class="comment">/*日，即一个月中的第几天，1-31*/</span></span><br><span class="line">    <span class="type">int</span> tm_mon;  <span class="comment">/*月， 从一月算起，0-11*/</span>  <span class="number">1</span>+p-&gt;tm_mon;</span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">/*年， 从1900至今已经多少年*/</span>  <span class="number">1900</span>＋ p-&gt;tm_year;</span><br><span class="line">    <span class="type">int</span> tm_wday; <span class="comment">/*星期，一周中的第几天， 从星期日算起，0-6*/</span></span><br><span class="line">    <span class="type">int</span> tm_yday; <span class="comment">/*从今年1月1日到目前的天数，范围0-365*/</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">/*日光节约时间的旗标*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span>  time1 = <span class="built_in">time</span>(<span class="literal">NULL</span>);<span class="comment">//获取系统时间，单位为秒;</span></span><br><span class="line">tm* t = <span class="built_in">localtime</span>(&amp;time1); <span class="comment">//将换取的time_t时间转换为 struct tm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *t)</span></span>; <span class="comment">//取得从1970年1月1日至今的秒数  </span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span></span>; <span class="comment">//将结构中的信息转换为真实世界的时间，以字符串的形式显示  </span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span></span>; <span class="comment">//将timep转换为真是世界的时间，以字符串显示，它和asctime不同就在于传入的参数形式不一样  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="built_in">gmtime</span>(<span class="type">const</span> <span class="type">time_t</span> *timep); <span class="comment">//将time_t表示的时间转换为没有经过时区转换的UTC时间，是一个struct tm结构指针   </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *<span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span> *timep); <span class="comment">//和gmtime类似，但是它是经过时区转换的时间。  </span></span><br><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span></span>; <span class="comment">//将struct tm 结构的时间转换为从1970年至今的秒数  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv, <span class="keyword">struct</span> timezone *tz)</span></span>; <span class="comment">//返回当前距离1970年的秒数和微妙数，后面的tz是时区，一般不用  </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time2)</span></span>; <span class="comment">//返回两个时间相差的秒数  </span></span><br></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ol><li><p>01背包，物品最多只能放一次</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=w[i])dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]]+v[i]);<span class="comment">//从上一行找</span></span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 降为一维数组</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;=w[i];j--)&#123;<span class="comment">// 从后向前便利，只会计算一次</span></span><br><span class="line">dp[j] = max(dp[j], dp[j-w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全背包问题，物品可重复放</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 二维</span><br><span class="line"><span class="type">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j-w[i]] + v[i]); <span class="comment">// 与01区别是从当前行找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 一维</span><br><span class="line"><span class="type">int</span> dp[n_1] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=n;j++)&#123;<span class="comment">// 从前向后便利，多次计算之前的</span></span><br><span class="line">dp[j] = max(dp[j], dp[j-w[i]] + v[i]);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用操作</title>
      <link href="/2024/02/09/ArchLinux/"/>
      <url>/2024/02/09/ArchLinux/</url>
      
        <content type="html"><![CDATA[<h1 id="ArchLinux"><a href="#ArchLinux" class="headerlink" title="ArchLinux"></a>ArchLinux</h1><h2 id="optimus-manager"><a href="#optimus-manager" class="headerlink" title="optimus-manager"></a>optimus-manager</h2><ul><li>在终端使用命令切换显卡</li><li>先运行 prime-offload</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换为英伟达显卡</span></span><br><span class="line">optimus-manager --switch nvidia</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换为intel核显</span></span><br><span class="line">optimus-manager --switch intel</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无效</span></span><br><span class="line">sudo prime-select nvidia # 切换nvidia显卡</span><br><span class="line">sudo prime-select intel  # 切换intel显卡</span><br><span class="line">sudo prime-select query  # 查看当前使用的显卡</span><br></pre></td></tr></table></figure><blockquote><p>journalctl -p 3 -xb 查看系统日志</p></blockquote><ul><li>glxinfo命令可以查看当前正在使用的显卡。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换前默认Intel</span></span><br><span class="line">[rainerosion@rains-arch ~]$ glxinfo | grep &quot;OpenGL renderer&quot;</span><br><span class="line">OpenGL renderer string: Mesa DRI Intel(R) HD Graphics 4600 (HSW GT2)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换NVIDIA显卡后</span></span><br><span class="line">[rainerosion@rains-arch ~]$ glxinfo | grep &quot;OpenGL renderer&quot;</span><br><span class="line">OpenGL renderer string: GeForce GTX 950M/PCIe/SSE2</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>查看驱动版本信息</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /usr/src | grep nvidia</span><br></pre></td></tr></table></figure><ul><li>查看显卡</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lspci -k | grep -A 2 -E &quot;(VGA|3D)&quot;</span><br></pre></td></tr></table></figure><h2 id="切换nvidia驱动后重启无法进入图形界面"><a href="#切换nvidia驱动后重启无法进入图形界面" class="headerlink" title="切换nvidia驱动后重启无法进入图形界面"></a>切换nvidia驱动后重启无法进入图形界面</h2><blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">按ctrl+alt+f2进入命令行，输入用户名密码进入（建议），输入命令nvidia-smi查看显卡是否运行正常</span><br><span class="line"></span><br><span class="line">运行nvidia-xconfig生成配置</span><br><span class="line">输入lspci | grep -E &quot;VGA|3D&quot;查看你的显卡PCI地址，</span><br><span class="line">将类似图中每行最前面的00.02.0转换成PCI:0:2:0，填在下面代码块中BusID那里，我使用的是NVIDIA，按照图中应该为PCI:1:0:0。将下面代码块添加到/etc/X11/xorg.conf文件中（同理，如果你是使用nvidia-xconfig后无法进入图形界面，你可以（删除/etc/X11/xorg.conf来重新进入图形界面）谨慎操作！！！）：</span><br><span class="line">Section &quot;Module&quot;</span><br><span class="line"><span class="code">    Load &quot;modesetting&quot;</span></span><br><span class="line"><span class="code">EndSection</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line"><span class="code">    Identifier &quot;nvidia&quot;</span></span><br><span class="line"><span class="code">    Driver &quot;nvidia&quot;</span></span><br><span class="line"><span class="code">    BusID &quot;PCI:1:0:0&quot;</span></span><br><span class="line"><span class="code">    Option &quot;AllowEmptyInitialConfiguration&quot;</span></span><br><span class="line"><span class="code">EndSection</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">编辑/usr/share/sddm/scripts/Xsetup文件，将下列内容添加到文件中</span><br><span class="line">xrandr --setprovideroutputsource modesetting NVIDIA-0</span><br><span class="line">xrandr --auto</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="切换回intel"><a href="#切换回intel" class="headerlink" title="切换回intel"></a>切换回intel</h2><blockquote><p>sudo vim &#x2F;etc&#x2F;optimus-manager&#x2F;optimus-manager.conf</p><p>修改 startup_mode&#x3D;integrated  后 注销</p></blockquote><h2 id="登录选择位置"><a href="#登录选择位置" class="headerlink" title="登录选择位置"></a>登录选择位置</h2><blockquote><p>&#x2F;usr&#x2F;share&#x2F;xsessions</p></blockquote><h2 id="nmcli-连接wifi"><a href="#nmcli-连接wifi" class="headerlink" title="nmcli 连接wifi"></a>nmcli 连接wifi</h2><blockquote><p>nmcli dev 查看网络设备</p><p>nmcli r wifi on 打开wifi</p><p>nmcli r wifi off 关闭wifi</p><p>nmcli dev wifi 扫描wifi </p></blockquote><blockquote><ol><li>创建wifi连接</li></ol><p>$ nmcli device wifi connect {wifi名} password {密码}</p><ol start="2"><li>删除wifi连接</li></ol><p>$ nmcli con del {wifi名}</p><ol start="3"><li>启用wifi连接</li></ol><p>$ nmcli connection up {wifi名}</p><p>$ nmcli device con {网卡名}</p><ol start="4"><li>查看已有连接</li></ol><p>$ nmcli con</p></blockquote><ul><li>若报错<code>Error: Connection activation failed: (7) Secrets were required, but not provided.</code> 删除连接记录</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nmcli c</span> </span><br><span class="line">NAME                UUID                                  TYPE      DEVICE</span><br><span class="line">eno1                3e755f37-3cff-314d-bb1b-4efebb6ce566  ethernet  eno1</span><br><span class="line">OpenWrt             14ad438b-9b2b-43c6-a3d1-66dd3bb987dc  wifi      --</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nmcli c delete OpenWrt</span></span><br><span class="line">Connection &#x27;OpenWrt&#x27; (14ad438b-9b2b-43c6-a3d1-66dd3bb987dc) successfully deleted.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nmcli device wifi connect <span class="string">&quot;OpenWrt&quot;</span> password 00000000</span></span><br><span class="line">Device &#x27;wlp58s0&#x27; successfully activated with &#x27;180a3ce4-ba1f-405a-94f1-684e538a7be9&#x27;.</span><br></pre></td></tr></table></figure><p>但是隐藏了SSID的则需要额外操作，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmcli c add type wifi con-name &quot;自定义连接名称&quot; ifname &quot;无线网卡名称&quot; ssid &quot;WiFi的名字&quot;</span><br><span class="line">nmcli con modify &quot;自定义连接名称&quot; wifi-sec.key-mgmt wpa-psk</span><br><span class="line">nmcli con modify &quot;自定义连接名称&quot; wifi-sec.psk &quot;WiFi的密码&quot;</span><br><span class="line">nmcli con up &quot;自定义连接名称&quot;</span><br></pre></td></tr></table></figure><p>查看网卡信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网卡信息：</span></span><br><span class="line">nmcli dev show wlp7s0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建网卡</span></span><br><span class="line">nmcli connection add type bridge ifname br0 stp no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看桥接绑定信息</span></span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure><h2 id="创建证书连接"><a href="#创建证书连接" class="headerlink" title="创建证书连接"></a>创建证书连接</h2><blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli connection add \</span><br><span class="line"> type wifi con-name &quot;IMUNET-NG&quot; ifname wlp7s0 ssid &quot;IMUNET-NG&quot; -- \</span><br><span class="line"> wifi-sec.key-mgmt wpa-eap 802-1x.eap ttls \</span><br><span class="line"> 802-1x.phase2-auth mschapv2 802-1x.identity &quot;32309140&quot; \</span><br><span class="line"> 802-1x.password &quot;131539&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">启动时(第一次)：</span><br><span class="line">nmcli --ask connection up IMUNET-NG</span><br></pre></td></tr></table></figure></blockquote><h2 id="nmcli-创建网桥"><a href="#nmcli-创建网桥" class="headerlink" title="nmcli  创建网桥"></a>nmcli  创建网桥</h2><p>注意: 仅有线网卡可以</p><ol><li>添加新的网桥： <code>nmcli connection add type bridge con-name virbr0 ifname virbr0 autoconnect yes</code></li><li>创建子网卡： <code>nmcli con add type bridge-slave ifname $&#123;网卡名&#125; master $&#123;网桥名&#125;</code></li><li>打开 br0： <code>nmcli con up br0</code></li><li></li></ol><h2 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h2><p>netstat -anp | grep 端口号</p><p>lsof  -i: 端口号</p><p>ps -ef 查看进程</p><p>w , tty</p><p>pkill 命令：杀死终端中所有命令 - pkill -9 -t pts&#x2F;0</p><h2 id="patch补丁"><a href="#patch补丁" class="headerlink" title="patch补丁"></a>patch补丁</h2><blockquote><p> Reversed (or previously applied) patch detected! Assume -R? [n]</p></blockquote><ul><li><code>-t</code>：该参数遇到这种情况直接将打过补丁的文件恢复原样，即未打补丁之前的状态</li><li><code>-f</code>：该参数遇到这种情况则继续打补丁，当然一般情况下会报错，毕竟对比不一致了</li><li><code>-N</code>：忽略该文件</li></ul><p>基本命令语法：<br>　　patch [-R] {-p(n)} [–dry-run] &lt; patch_file_name<br>　　p：为path的缩写。<br>　　n：指将patch文件中的path第n条’&#x2F;’及其左边部分取消。<br>　　-R：卸载patch包。<br>　　–dry-run：尝试patch软件，并不真正修改软件。</p><p>　　例如：</p><p>　　$ patch -p1 &lt; &#x2F;home&#x2F;sense&#x2F;patch-2.6.19.1      安装补丁<br>　　$ patch -p1 -R &lt; &#x2F;home&#x2F;sense&#x2F;patch-2.6.19.1 卸载补丁</p><h2 id="DPI设置"><a href="#DPI设置" class="headerlink" title="DPI设置"></a>DPI设置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~/.Xresources</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认96</span></span><br><span class="line">Xft.dpi: 192</span><br><span class="line">xrdb -merge /home/papillon/.Xresources</span><br></pre></td></tr></table></figure><p>应用程序缩放：</p><blockquote><p>–force-device-scale-factor&#x3D;2 </p></blockquote><h2 id="双屏设置"><a href="#双屏设置" class="headerlink" title="双屏设置"></a>双屏设置</h2><blockquote><p>xrandr –output eDP-1-1 –primary –mode 3840x2160 –scale 1x1 –output DP-0 –mode 1920x1080 –scale 2x2 –left-of eDP-1-1 </p></blockquote><h2 id="向日葵启动"><a href="#向日葵启动" class="headerlink" title="向日葵启动"></a>向日葵启动</h2><blockquote><p>sudo systemctl start runsunloginclient.service </p><p>sudo systemctl enable runsunloginclient.service</p></blockquote><h2 id="chrome-代理"><a href="#chrome-代理" class="headerlink" title="chrome 代理"></a>chrome 代理</h2><ol><li><code>sudo google-chrome --proxy-server=&quot;127.0.0.1:8080&quot; --no-sandbox</code></li><li>使用代理插件</li></ol><h2 id="调整透明度"><a href="#调整透明度" class="headerlink" title="调整透明度"></a>调整透明度</h2><blockquote><ul><li>xprop 点击窗口获取窗口信息 WM_CLASS(STRING) 后的内容</li><li>vim ~&#x2F;.config&#x2F;picom&#x2F;picom.conf </li><li>在透明度中新加一行更改指定透明度</li></ul></blockquote><h2 id="调节音量"><a href="#调节音量" class="headerlink" title="调节音量"></a>调节音量</h2><p>alsamixer</p><blockquote><p>pgup&#x2F;pgdowm 增减音量</p><p>1~9 调节音量到 10%-90%</p></blockquote><h2 id="调节屏幕亮度"><a href="#调节屏幕亮度" class="headerlink" title="调节屏幕亮度"></a>调节屏幕亮度</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动切换</span></span><br><span class="line">切换root用户</span><br><span class="line">cd /sys/class/backlight/intel_backlight</span><br><span class="line">echo 0~512 &gt; brightness</span><br><span class="line"></span><br><span class="line">sudo pacman -S acpilight</span><br><span class="line">sudo gpasswd video -a 用户名 # 将当前用户添加到video实现免root控制亮度</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前亮度</span></span><br><span class="line">xbacklight -get</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置亮度</span></span><br><span class="line">xbacklight -set 70</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加亮度</span></span><br><span class="line">xbacklight -inc 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">减少亮度</span></span><br><span class="line">xbacklight -dec 10</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切换内核"><a href="#切换内核" class="headerlink" title="切换内核"></a>切换内核</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 grub 配置不是必须的，下面那个才是必须的。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo nano /etc/default/grub</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这三行是将子菜单展开，这样不用点击 advanced 进去了</span></span><br><span class="line">GRUB_DISABLE_SUBMENU=y</span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_SAVEDEFAULT=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待时间我之前设置为 0s 的，0 就不显示了，这里改大一点 3s</span></span><br><span class="line">GRUB_TIMEOUT=3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改完保存退出 -----------------------------------------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新下 grub 的配置文件，让上面的设置生效，这一步是一定要做的。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo grub-mkconfig -o /boot/grub/grub.cfg</span></span><br><span class="line">正在生成 grub 配置文件 ...</span><br><span class="line">找到 Linux 镜像：/boot/vmlinuz-linux-lts</span><br><span class="line">找到 initrd 镜像：/boot/amd-ucode.img /boot/initramfs-linux-lts.img</span><br><span class="line">Found fallback initrd image(s) in /boot:  amd-ucode.img initramfs-linux-lts-fallback.img</span><br><span class="line">找到 Linux 镜像：/boot/vmlinuz-linux</span><br><span class="line">找到 initrd 镜像：/boot/amd-ucode.img /boot/initramfs-linux.img</span><br><span class="line">Found fallback initrd image(s) in /boot:  amd-ucode.img initramfs-linux-fallback.img</span><br><span class="line">警告： os-prober will not be executed to detect other bootable partitions.</span><br><span class="line">Systems on them will not be added to the GRUB boot configuration.</span><br><span class="line">Check GRUB_DISABLE_OS_PROBER documentation entry.</span><br><span class="line">Adding boot menu entry for UEFI Firmware Settings ...</span><br><span class="line">完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="救援模式"><a href="#救援模式" class="headerlink" title="救援模式"></a>救援模式</h2><p>linux系统奔溃后的紧急救援模式<br>当 Linux 系统奔溃时，可以进入紧急救援模式（emergency mode）来检查和修复系统问题。以下是进入紧急救援模式的步骤：</p><p>在启动 GRUB 时，选择要启动的 Linux 内核。</p><p>按下 e 键进入编辑模式，在 kernel 行的末尾添加 single 或 emergency。</p><p>按下 Ctrl + X 启动系统。</p><p>系统会自动进入救援模式，此时会提示输入 root 用户密码，输入密码后即可进入救援模式。</p><p>在救援模式下，可以进行以下操作：</p><p>检查文件系统：使用 fsck 命令检查文件系统，并修复错误。</p><p>挂载文件系统：使用 mount 命令挂载文件系统，使得可以访问文件系统中的文件。</p><p>修改密码：使用 passwd 命令修改用户密码。</p><p>网络配置：使用 ifconfig 命令配置网络。</p><p>安装软件：使用 yum 或 apt-get 命令安装软件。</p><p>退出救援模式：使用 exit 命令退出救援模式，重新启动系统。</p><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul><li><strong>关机</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown -h 0 #&lt;==O秒后关机</span><br><span class="line">shutdown -h now #&lt;==现在关机</span><br><span class="line">shutdown -h 10 #&lt;==10分钟后关机</span><br><span class="line">shutdown -h 23:20 #&lt;==23：20分关机</span><br><span class="line">shutdown -c #&lt;==取消shutdown关机命令</span><br><span class="line">init 0 #&lt;==立马关机（切换运行级别为0，推荐使用）</span><br><span class="line">halt #&lt;==立马关机</span><br><span class="line">poweroff #&lt;==立马关机</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>重启</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown -r now #&lt;==现在重启</span><br><span class="line">shutdown -r 23:20 &amp; #&lt;==23：20分重启，加&amp;符号代表把该命令转到后台处理</span><br><span class="line">reboot #&lt;==立马重启（推荐使用）</span><br><span class="line">init 6 #&lt;==立马重启（切换运行级别为6，推荐使用）</span><br></pre></td></tr></table></figure><ul><li><strong>注销</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logout #&lt;==立马注销</span><br><span class="line">exit #&lt;==立马注销</span><br><span class="line">在SecureCRT软件中，按快捷键：Ctrl + d #&lt;==推荐使用</span><br></pre></td></tr></table></figure><h2 id="切换java版本"><a href="#切换java版本" class="headerlink" title="切换java版本"></a>切换java版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看archlinux-java使用说明</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">archlinux-java --<span class="built_in">help</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看jdk状态</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">archlinux-java status</span></span><br><span class="line"></span><br><span class="line">Available Java environments:</span><br><span class="line">  java-11-openjdk</span><br><span class="line">  java-8-openjdk (default)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取默认jdk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">archlinux-java get</span></span><br><span class="line"></span><br><span class="line">java-8-openjdk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认jdk</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo archlinux-java <span class="built_in">set</span> java-11-openjdk</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看切换后的jdk版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -version</span></span><br><span class="line"></span><br><span class="line">openjdk version &quot;11.0.13&quot; 2021-10-19</span><br><span class="line">OpenJDK Runtime Environment (build 11.0.13+8)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 11.0.13+8, mixed mode)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="crontab脚本"><a href="#crontab脚本" class="headerlink" title="crontab脚本"></a>crontab脚本</h2><blockquote><ul><li>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)</li><li>-r : 删除目前的时程表</li><li>-l : 列出目前的时程表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min hour day mon week program</span><br></pre></td></tr></table></figure><table><thead><tr><th>每分钟定时执行一次</th><th>* * * * *</th></tr></thead><tbody><tr><td>每小时定时执行一次</td><td>0 * * * *</td></tr><tr><td>每天定时执行一次</td><td>0 0 * * *</td></tr><tr><td>每周定时执行一次</td><td>0 0 * * 0</td></tr><tr><td>每月定时执行一次</td><td>0 0 1 * *</td></tr><tr><td>每月最后一天定时执行一次</td><td>0 0 L * *</td></tr><tr><td>每年定时执行一次</td><td>0 0 1 1 *</td></tr></tbody></table></blockquote><ul><li>要确保有对目标文件的权限</li><li>命令要使用绝对路径</li></ul><h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">c： 显示完整的命令</span><br><span class="line">d： 更改刷新频率</span><br><span class="line">f： 增加或减少要显示的列(选中的会变成大写并加*号)</span><br><span class="line">F： 选择排序的列</span><br><span class="line">h： 显示帮助画面</span><br><span class="line">H： 显示线程</span><br><span class="line">i： 忽略闲置和僵死进程</span><br><span class="line">k： 通过给予一个PID和一个signal来终止一个进程。（默认signal为15。在安全模式中此命令被屏蔽）</span><br><span class="line">l:  显示平均负载以及启动时间（即显示影藏第一行）</span><br><span class="line">m： 显示内存信息</span><br><span class="line">M： 根据内存资源使用大小进行排序</span><br><span class="line">N： 按PID由高到低排列</span><br><span class="line">o： 改变列显示的顺序</span><br><span class="line">O： 选择排序的列，与F完全相同</span><br><span class="line">P： 根据CPU资源使用大小进行排序</span><br><span class="line">q： 退出top命令</span><br><span class="line">r： 修改进程的nice值(优先级)。优先级默认为10，正值使优先级降低，反之则提高的优先级</span><br><span class="line">s： 设置刷新频率（默认单位为秒，如有小数则换算成ms）。默认值是5s，输入0值则系统将不断刷新</span><br><span class="line">S： 累计模式（把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+ ）</span><br><span class="line">T： 根据进程使用CPU的累积时间排序</span><br><span class="line">t： 显示进程和CPU状态信息（即显示影藏CPU行）</span><br><span class="line">u： 指定用户进程</span><br><span class="line">W： 将当前设置写入~/.toprc文件，下次启动自动调用toprc文件的设置</span><br><span class="line">&lt;： 向前翻页</span><br><span class="line">&gt;： 向后翻页</span><br><span class="line">?： 显示帮助画面</span><br><span class="line">1(数字1)： 显示每个CPU的详细情况</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#上传本地文件夹到Linux</span><br><span class="line">scp -r -p 22 &#123;本地文件夹&#125; Linux用户名@ip地址:Linux绝对路径</span><br><span class="line">#上传文件</span><br><span class="line">scp -p 22 &#123;本地文件&#125; Linux用户名@ip地址:Linux绝对路径</span><br><span class="line"></span><br><span class="line"># 上传</span><br><span class="line">去掉指定端口号参数-p, 并将上述路径舒徐调换即可</span><br><span class="line"></span><br><span class="line">#下载</span><br><span class="line">scp -p 22 linux用户名@ipdizhi:文件路径 &#123;本地路径&#125;</span><br></pre></td></tr></table></figure><h2 id="ln-软链接"><a href="#ln-软链接" class="headerlink" title="ln 软链接"></a>ln 软链接</h2><p>ln -s 【目标目录】 【软链接地址】</p><p>目标目录】指软连接指向的目标目录下，【软链接地址】指“快捷键”文件名称，该文件是被指令创建的。</p><p>rm -rf 【软链接地址】</p><p>ln -snf 【新目标目录】 【软链接地址】</p><h2 id="ROFI-Script"><a href="#ROFI-Script" class="headerlink" title="ROFI Script"></a>ROFI Script</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><blockquote><p>rofi -show [mine] -modi “mine:~&#x2F;scripts&#x2F;rofi.sh”</p></blockquote><p>返回选中的文本</p><blockquote><p>ls | rofi -dmenu </p><p>history | rofi -dmenu.    h&#x3D;$(history | rofi -dmenu)</p></blockquote><h2 id="屏蔽磁盘"><a href="#屏蔽磁盘" class="headerlink" title="屏蔽磁盘"></a>屏蔽磁盘</h2><p>1　启动后的禁用 无需重启</p><p>　（sdx是你的磁盘 udev的更新可能会导致磁盘重新出现 在向系统添加&#x2F;删除磁盘也可能会改变）</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1</span>&gt;<span class="regexp">/sys/</span>block/sdx/device/<span class="keyword">delete</span> </span><br></pre></td></tr></table></figure></blockquote><p>2　基本上你创建一个文件<code>/etc/udev/rules.d/99-hide-disks.rules</code> ，你在其中放置该行</p><blockquote><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">KERNEL</span>==<span class="string">&quot;sda1&quot;</span>, ENV&#123;UDISKS_PRESENTATION_HIDE&#125;=<span class="string">&quot;1&quot;</span> </span><br></pre></td></tr></table></figure></blockquote><p>　 其中<em>sda1</em>是您要隐藏的分区的名称。 在某些系统中它也可以</p><blockquote><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">KERNEL</span>==<span class="string">&quot;sda1&quot;</span>, ENV&#123;UDISKS_IGNORE&#125;=<span class="string">&quot;1&quot;</span> </span><br></pre></td></tr></table></figure></blockquote><p>   然后你重新启动。</p><h2 id="QQ闪退"><a href="#QQ闪退" class="headerlink" title="QQ闪退"></a>QQ闪退</h2><blockquote><p>文件问题： sudo chattr +i ~&#x2F;.config&#x2F;QQ&#x2F;crash_files&#x2F;</p><p>代理问题： 不要走代理</p></blockquote><h1 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h1><h2 id="强制安装"><a href="#强制安装" class="headerlink" title="强制安装"></a>强制安装</h2><blockquote><p>pacman -S –overwrite ‘<em>‘ 要覆盖的文件模式</em>*</p></blockquote><h2 id="在-Arch-Linux-上安装-Debtap"><a href="#在-Arch-Linux-上安装-Debtap" class="headerlink" title="在 Arch Linux 上安装 Debtap"></a>在 Arch Linux 上安装 Debtap</h2><blockquote><p>要安装 Debtap，启动终端并使用 AUR 助手安装它：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;yay -S debtap</span><br><span class="line">&gt;sudo debtap -u</span><br></pre></td></tr></table></figure><p>使用 cd 命令进入 DEB 文件的目录并使用 Debtap 开始转换包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;cd ~/Downloads</span><br><span class="line">&gt;debtap yourfile.deb</span><br></pre></td></tr></table></figure><p>Debtap 将创建一个“<strong>你的文件.zst</strong>” 文件，您可以使用包管理器轻松安装，在本例中为 pacman。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;sudo pacman -U yourfile.zst</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用dpkg"><a href="#使用dpkg" class="headerlink" title="使用dpkg"></a>使用dpkg</h2><blockquote><ol><li>安装dpkg</li><li>使用dpkg安装deb包</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;yay -S dpkg</span><br><span class="line">&gt;dpkg -i .deb包名</span><br></pre></td></tr></table></figure></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>pacmam -U package.pkg.tar.gz 从安装本地package包</p><h2 id="多线程编译"><a href="#多线程编译" class="headerlink" title="多线程编译"></a>多线程编译</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/makepkg.conf </span><br></pre></td></tr></table></figure><p>找到 MAKEFLAGS 参数,修改 -j 后面的参数为想要用多少个核编译,保持并退出</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">MAKEFLAGS=&quot;-j8&quot;</span><br></pre></td></tr></table></figure><h2 id="代理问题"><a href="#代理问题" class="headerlink" title="代理问题"></a>代理问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 http 代理</span></span><br><span class="line">export http=http://127.0.0.1:7890</span><br><span class="line">export https=http://127.0.0.1:7890</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或, 设置 socket 代理(clash)</span></span><br><span class="line">export http_proxy=socks5://127.0.0.1:7891</span><br><span class="line">export https_proxy=socks5://127.0.0.1:7891</span><br></pre></td></tr></table></figure><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>带多个参数的命令 要加 command 修饰，例如</p><p><code>command gcc -g main.c -o main</code></p></blockquote><h1 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h1><h2 id="qemu安装"><a href="#qemu安装" class="headerlink" title="qemu安装"></a>qemu安装</h2><ol><li>i386:  qemu-system-i386</li><li>x86_64: qemu-system-x86_64</li><li>arm : qemu-system-arm</li><li>arm64: qemu-system-aarch64</li></ol><h2 id="交叉编译链安装"><a href="#交叉编译链安装" class="headerlink" title="交叉编译链安装"></a>交叉编译链安装</h2><ol><li>arm-linux-gnueabihf-</li><li>aarch64-linux-gnu-</li></ol><h2 id="编译linux内核"><a href="#编译linux内核" class="headerlink" title="编译linux内核"></a>编译linux内核</h2><blockquote><p>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- defconfig<br>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- menuconfig<br>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- -j 8</p></blockquote><h2 id="制作跟文件系统-busybox"><a href="#制作跟文件系统-busybox" class="headerlink" title="制作跟文件系统 busybox"></a>制作跟文件系统 busybox</h2><ol><li>下载源码，并设置对应目标的架构，编译。</li><li>qemu-img create xxx.img 4g 创建4g磁盘，使用mkfs.ext4 xxx.img 格式化<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 1g (这个根据实际需要进行配置) 的 raw 格式的空镜像磁盘</span> </span><br><span class="line">qemu-img create rootfs.img 1g </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将创建的磁盘格式化成 ext4 类型的文件系统</span> </span><br><span class="line">mkfs.ext4 rootfs.img </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个文件用来挂载该镜像（用来将编译好的内容装入磁盘，载体）</span> </span><br><span class="line">mkdir rootfs </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 rootfs.img 挂载到 rootfs 文件夹</span> </span><br><span class="line">sudo mount -o loop rootfs.img rootfs </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将在 busybox 中编译的内容移动到刚新建的文件夹 rootfs 中(等价于拷贝到了 rootfs.img 磁盘中)</span> </span><br><span class="line">cd rootfs </span><br><span class="line">sudo cp -r ../busybox/_install/* . </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">补充一些必要的文件夹</span> </span><br><span class="line">sudo mkdir proc sys dev etc etc/init.d</span><br><span class="line"></span><br><span class="line">cd etc/init.d/ sudo touch rcS sudo vi rcS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件内容如下</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc# 挂载文件系统到 /proc 目录, 它提供了一个接口来访问内核和进程信息</span><br><span class="line">mount -t sysfs none /sys# 挂载sysfs文件系统到 /sys 目录, 提供了一种方式来访问和调整内核的运行时信息</span><br><span class="line">/sbin/mdev -s# 使用mdev（是BusyBox的一部分）来初始化/dev目录，它负责创建设备节点</span><br><span class="line"># -s 告诉 mdev 启动是扫描 /sys 目录并创建设备节点 </span><br><span class="line"># /sys中包含了当前系统中硬件设备的详细信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo chmod +x rcS</span><br><span class="line"></span><br><span class="line">cd ../..</span><br><span class="line">sudo umount rootfs</span><br></pre></td></tr></table></figure></li></ol><h2 id="qemu启动系统"><a href="#qemu启动系统" class="headerlink" title="qemu启动系统"></a>qemu启动系统</h2><p><code>qemu-system-aarch64 -M virt -cpu cortex-a57 -m 256M -nographic -kernel ../linux-6.7/arch/arm64/boot/Image -drive file=rootfs.img,format=raw,id=hd0,if=none -device virtio-blk-device,drive=hd0 -append &quot;root=/dev/vda rw console=ttyAMA0&quot; </code></p><h2 id="虚拟机和宿主机通讯"><a href="#虚拟机和宿主机通讯" class="headerlink" title="虚拟机和宿主机通讯"></a>虚拟机和宿主机通讯</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA随笔</title>
      <link href="/2024/02/09/FPGA/"/>
      <url>/2024/02/09/FPGA/</url>
      
        <content type="html"><![CDATA[<h1 id="FGPA"><a href="#FGPA" class="headerlink" title="FGPA"></a>FGPA</h1><h2 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">编写 Verilog (.v) 文件：</span><br><span class="line"></span><br><span class="line">使用 Verilog 或其他支持的硬件描述语言编写您的 FPGA 设计代码。Verilog 文件描述了电路的行为和结构。</span><br><span class="line">编写 Constraint (.cst) 文件：</span><br><span class="line"></span><br><span class="line">编写约束文件，也称为约束条件文件。该文件描述了时序、引脚分配、时钟频率等约束条件，以确保设计在 FPGA 上正确运行。</span><br><span class="line">综合：</span><br><span class="line"></span><br><span class="line">使用综合工具，如 Yosys，将 Verilog 代码转换为逻辑网表。综合工具将分析和优化设计，并生成逻辑网表文件。</span><br><span class="line">实现：</span><br><span class="line"></span><br><span class="line">使用物理设计工具（例如 nextpnr, Vivado、Quartus Prime、iCEcube2 等），将逻辑网表映射到目标 FPGA 设备的物理资源上。该步骤包括布局（将逻辑元件放置在 FPGA 芯片上的位置）和布线（将逻辑元件之间的连线连接起来）。</span><br><span class="line">生成 Bitstream 文件：</span><br><span class="line"></span><br><span class="line">在实现步骤完成后，生成 FPGA 设备可识别的 Bitstream 文件。Bitstream 文件包含了将设计配置到 FPGA 芯片上所需的详细信息，例如逻辑元件的位置、连线信息和时钟设置。</span><br><span class="line">配置 FPGA 开发板：</span><br><span class="line"></span><br><span class="line">将生成的 Bitstream 文件加载到 FPGA 开发板上。这通常需要使用特定的软件工具或命令行工具，例如 Vivado Hardware Manager、Quartus Programmer 或 openFPGALoader。</span><br></pre></td></tr></table></figure><h1 id="veirlog语言"><a href="#veirlog语言" class="headerlink" title="veirlog语言"></a>veirlog语言</h1><p>input&#x2F;output 参数默认是wire类型。<br>wire : 组合逻辑，不涉及时序，当电路变化时，跟着变化<br>reg : 用于时序逻辑，当电路变化时，要等到下一个时钟才变化。<br>所以 assign 赋值要比在always中赋值快一个周期。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="yosys-综合工具。"><a href="#yosys-综合工具。" class="headerlink" title="yosys: 综合工具。"></a>yosys: 综合工具。</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet"> 1.</span> 启动 Yosys：</span><br><span class="line"><span class="bullet"> -</span> 在命令行中输入 <span class="code">`yosys`</span> 命令来启动 Yosys 工具。</span><br><span class="line"></span><br><span class="line"><span class="bullet"> 2.</span> 导入设计文件：</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 在 Yosys 提示符下，使用</span><br><span class="line"><span class="code">     read_verilog</span></span><br><span class="line"><span class="code">     命令导入设计文件：</span></span><br><span class="line"><span class="code">     复制</span></span><br><span class="line"><span class="code">     yosys&gt; read_verilog design.v</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">3.</span> 综合设计：</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 使用</span><br><span class="line"><span class="code">     synth</span></span><br><span class="line"><span class="code">     命令对设计进行综合：</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">     复制</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">     yosys&gt; synth &lt;synthesis_command&gt;</span></span><br><span class="line"><span class="code">     &lt;synthesis_command&gt;</span></span><br><span class="line"><span class="code">     表示您选择的综合命令。Yosys 支持不同的综合命令，如</span></span><br><span class="line"><span class="code">     synth_ice40</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">     （针对 Lattice iCE40 FPGA）或</span></span><br><span class="line"><span class="code">     synth_xilinx</span></span><br><span class="line"><span class="code">     （针对 Xilinx FPGA）。您可以根据目标 FPGA 平台选择适当的综合命令。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">4.</span> 查看综合结果：</span><br><span class="line"><span class="bullet">   -</span> 使用</span><br><span class="line"><span class="code">     show</span></span><br><span class="line"><span class="code">     命令查看综合后的设计：</span></span><br><span class="line"><span class="code">     复制</span></span><br><span class="line"><span class="code">     yosys&gt; show</span></span><br><span class="line"><span class="code">     这将显示综合生成的逻辑网表。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">5.</span> 导出网表：</span><br><span class="line"><span class="bullet">   -</span> 使用</span><br><span class="line"><span class="code">     write_verilog</span></span><br><span class="line"><span class="code">     命令将综合后的逻辑网表导出为 Verilog 文件：</span></span><br><span class="line"><span class="code">     复制</span></span><br><span class="line"><span class="code">     yosys&gt; write_verilog synthesized.v</span></span><br><span class="line"><span class="code">     这将生成一个名为synthesized.v的文件，其中包含综合后的逻辑网表。</span></span><br></pre></td></tr></table></figure><h3 id="nextpnr-gowin-实现工具"><a href="#nextpnr-gowin-实现工具" class="headerlink" title="nextpnr-gowin: 实现工具"></a>nextpnr-gowin: 实现工具</h3><h3 id="openFPGALoader-烧录工具。"><a href="#openFPGALoader-烧录工具。" class="headerlink" title="openFPGALoader: 烧录工具。"></a>openFPGALoader: 烧录工具。</h3><h1 id="高云IDE启动过程"><a href="#高云IDE启动过程" class="headerlink" title="高云IDE启动过程"></a>高云IDE启动过程</h1><blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LD_PRELOAD=/usr/lib/libfreetype.so /opt/Gowin_V1.9/IDE/bin/gw_ide</span><br></pre></td></tr></table></figure></blockquote><h1 id="使用vscode开发环境"><a href="#使用vscode开发环境" class="headerlink" title="使用vscode开发环境"></a>使用vscode开发环境</h1><blockquote><p>OSS CAD Suite –&gt; Lushay Code(vscode插件) -&gt; 右下角 fpga toolchain</p><p>Verilog-HDL 语法高亮</p></blockquote><h1 id="iverilog-仿真"><a href="#iverilog-仿真" class="headerlink" title="iverilog 仿真"></a>iverilog 仿真</h1><ol><li>iverilog -o wave led_demo_tb.v led_demo.v</li><li>vvp -n wave -lxt2</li><li>gtkwave wave.vcdv</li></ol><h1 id="IP核"><a href="#IP核" class="headerlink" title="IP核"></a>IP核</h1><h2 id="CMT-clock-manager-tiles"><a href="#CMT-clock-manager-tiles" class="headerlink" title="CMT clock manager tiles"></a>CMT clock manager tiles</h2><p>1个CMT包含一个MMCM和1个PLL。</p><h3 id="MMCM"><a href="#MMCM" class="headerlink" title="MMCM"></a>MMCM</h3><h3 id="PPL锁相环"><a href="#PPL锁相环" class="headerlink" title="PPL锁相环"></a>PPL锁相环</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[ ] --&gt; |F_in| B(N)</span><br><span class="line">B --&gt; |F_ref| C[PFD]</span><br><span class="line">C --&gt; D[Charge Pump / Loop Filter &amp;VCO]</span><br><span class="line">D --&gt; J[F_vco]</span><br><span class="line">J --&gt; |M| C</span><br><span class="line">J --&gt; E[K]</span><br><span class="line">E --&gt; F[F_out1]</span><br><span class="line">E --&gt; G[F_out1]</span><br><span class="line">J --&gt; H[V]</span><br><span class="line">H --&gt; I[F_out2]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>N：前置分频计数器<br>PFD：相位频率检测器<br>Charge Pump：电荷泵<br>Loop Filter：环路滤波器<br>VCO：压控振荡器<br>M：反馈乘法器<br>K,V：后置分频器</p><h4 id="电路原理介绍："><a href="#电路原理介绍：" class="headerlink" title="电路原理介绍："></a>电路原理介绍：</h4><pre><code>首先Fin输入时钟，进入N预分频单元，出来的是FREF参考时钟，进入PFD频率相位检测电路，检测VCO反馈回来的时钟信号与参考时钟进行比较，然后将比较结果送入Charge，能得到一个电压信号，电压信号经过一个环路滤波器后，就是一个比较稳定的电压信号，这电压信号再来控制VCO压控振荡器，从来产生一个时钟信号Fvco，再次经过M的一个倍频，输入到PFD，这里就是一个环路反馈，不断调整达到一个平衡。当PFD=M就稳定下来，稳定下来之前需要一定时间。</code></pre><h2 id="单端口RAM"><a href="#单端口RAM" class="headerlink" title="单端口RAM"></a>单端口RAM</h2><p>输入只有一组数据线和一组地址线，只有一个时钟，读写共用地址线。</p><p>输出只有一个端口</p><p>所以单端口RAM读写操作不能同时进行</p><h2 id="伪双端口RAM"><a href="#伪双端口RAM" class="headerlink" title="伪双端口RAM"></a>伪双端口RAM</h2><p>输入只有一组数据线，两组地址线，两个时钟。</p><p>两个输出端口共用输出端口</p><p>所以一个端口只读，另一个端口只写，但写入和读取时钟可以不同，且位宽比可以不是1:1，即同时写A与读B可以速率不同。</p><h2 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h2><p>输入有两组地址线和两组数据线，两个时钟。</p><p>输出有两个分别的数据线</p><p>所以双端口RAM两个端口都可以分别读写，彼此互不干扰</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
          <category> gowin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32笔记</title>
      <link href="/2024/02/09/STM32/"/>
      <url>/2024/02/09/STM32/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><p>VDD: 电源正极 高电平<br>VSS: 电源负极 低电平</p><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>P置位第n位: P |&#x3D; (1 &lt;&lt; n)<br>Q清零第n位: Q &amp;&#x3D; ~(1 &lt;&lt; n)<br>R反转第n位: R ^&#x3D; (1 &lt;&lt; n)</p><h3 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h3><p>转换: (Addr &amp; 0xF0000000)+0x02000000+((Addr &amp; 0x00ffffff)&lt;&lt;5) + (n&lt;&lt;2)</p><blockquote><p>内存映射是对地址的封装，直接操作内存也可以实现。</p></blockquote><h2 id="引脚分类"><a href="#引脚分类" class="headerlink" title="引脚分类"></a>引脚分类</h2><p>电源<br>晶振IO<br>BOOT IO<br>复位IO<br>以上IO组成的系统称最小系统</p><h2 id="RCC"><a href="#RCC" class="headerlink" title="RCC"></a>RCC</h2><ol><li>RCC_CR</li><li>RCC_CFGR</li><li>RCC_CIR</li><li>RCC_APB2RSTR</li><li>RCC_APB1RSTR</li><li>RCC_AHBENR</li><li>RCC_AHBENR</li><li>RCC_AHB2ENR</li><li>RCC_AHB1ENR</li><li>RCC_BDCR</li><li>RCC_CSR</li></ol><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO:"></a>GPIO:</h2><p>专用总线:I2C, SPI, SDIO, FSMC, DCMI<br>普通总线: 蜂鸣器, LED, 按键</p><h3 id="寄存器描述"><a href="#寄存器描述" class="headerlink" title="寄存器描述"></a>寄存器描述</h3><ol><li>CRL 配置低寄存器</li><li>CRH 配置高寄存器</li><li>ODR 输入数据寄存器</li><li>IDR 输入数据寄存器</li><li>BSRR 位设置&#x2F;清楚寄存器</li><li>BRR 位清除寄存器</li><li>LCKR 配置锁定寄存器</li></ol><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1. 模拟输入: 不经过施密特触发器(TTL)直接接入</span><br><span class="line">2. 浮空输入: 即高阻输入,相当于电压表。但外界没有输入时，容易受到外界电磁干扰.</span><br><span class="line">3. 下拉输入: 无输入信号时端口电平被拉到低电平</span><br><span class="line">4. 上拉输入: 无输入信号时端口电平被拉到高电平</span><br><span class="line">5. 开漏输出: 只能输出低电平，只有接上拉电阻才能输出1。好处是更换外部电源即可以更改输出电源。</span><br><span class="line">6. 推挽输出: 可以输出高低电平,高电平由VDD决定,低电平由VSS决定。由两个三极管互补信号控制,电流大,驱动能力强.</span><br><span class="line">7. 复用开漏输出: 数据来自片上外设,而普通开漏输出来自输出数据寄存器(ODR)数据</span><br><span class="line">8. 复用推挽输出: 同上</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="IWDG-独立看门狗"><a href="#IWDG-独立看门狗" class="headerlink" title="IWDG 独立看门狗"></a>IWDG 独立看门狗</h2><p>递减计数器到0后，会自动复位，所以启用iwdg后要及时重装载计数器的值。12位，最大4096</p><p>是异常处理的最后手段，不可依赖，应在设计时尽量避免异常的发生。</p><p>没有中断，而WWDG有。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>启用iwdg后，LSI(内部低速时钟40khz)会自动开启</p><p>键寄存器iwdg_kr</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">写入0xAAAA,喂狗</span><br><span class="line">写入0x5555,解除pr和rlr寄存器的写保护</span><br><span class="line">写入0xCCCC,启用iwdg工作</span><br></pre></td></tr></table></figure><p>预分频寄存器iwdg_pr,设置时钟的预分频系数。psc&#x3D;4*2^prer.</p><p>重装载寄存器iwdg_rlr,存放重装载值，低12位有效。</p><p>状态寄存器iwdg_sr,用于判断预分频值和重装载值是否已经被更改。</p><h3 id="溢出时间计算"><a href="#溢出时间计算" class="headerlink" title="溢出时间计算"></a>溢出时间计算</h3><p>$$<br>T (out)&#x3D;\frac{psc<em>rlr}{f_{iwdg}}&#x3D;\frac{4</em>2^{prer}*rlr}{f_{iwdg}}， f_{iwdg}:iwdg的时钟频率<br>$$</p><h2 id="WWDG-窗口看门狗"><a href="#WWDG-窗口看门狗" class="headerlink" title="WWDG 窗口看门狗"></a>WWDG 窗口看门狗</h2><p>主要用于检测软件异常</p><p>递减计数器，能产生系统复位信号和提前唤醒中断.</p><p>计数器从0x40减到0x3F时产生复位（即T6位跳变到0）</p><p>计数器值大于W[6:0]时喂狗会复位</p><p>提前唤醒中断(EWI):计数器等于0x40时可产生</p><p>在窗口期内重装载计数器的值，防止复位。</p><p>使用PCLK1外部总线时钟，计数器寄存器7位，最大127~63</p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>T[6:0]从0x7F(127)开始递减计数，减到W[6:0] (窗口上限值，大于这个值时喂狗会产生复位，在上限值和下限值之间喂狗不会产生复位)，减到0x40(64)时可产生中断，减到0x3F(63)(窗口下限值)，产生复位。</p><h3 id="超时时间计算"><a href="#超时时间计算" class="headerlink" title="超时时间计算"></a>超时时间计算</h3><p>WWDG_CR控制寄存器，[6:0]有效，计数器（MSB到LSB，T6为0会产生复位）,[7]是WDGA 激活位，<code>0:禁用WWDG；1:使能看门狗</code> </p><p>WWDG_CFR:配置寄存器。T9 ：提前唤醒终端，计数器递减到0x40时产生中断，此中断中有复位后才能由硬件清零（还要使能NVIC）。T8:7 WDGTB:定时器时基。 2^WDGTB^计算分频器</p><p>WWDG_SR 状态寄存器。T0 EWIF： 提前唤醒中断标志，当计数器递减到0x40时由硬件置1.且只能由软件方式写0，如果不使能EWIF，此位也为1. 使能EWIF，信号会传到NVIC。</p><p>4096是固定预分频系数</p><h3 id="WWDG超时间计算"><a href="#WWDG超时间计算" class="headerlink" title="WWDG超时间计算"></a>WWDG超时间计算</h3><p>$$<br>T_{out}&#x3D;\frac{4096<em>2^{WDGTB}</em>(T[5:0]+1)}{F_{wwdg}}<br>$$</p><h3 id="WWDG配置步骤"><a href="#WWDG配置步骤" class="headerlink" title="WWDG配置步骤"></a>WWDG配置步骤</h3><ol><li>WWDG工作参数初始化 HAL_WWDG_Init()</li><li>WWDG MSP初始化 HAL_WWDG_MspInit() 配置NVIC,Clock等</li><li>设置优先级，使能中断 HAL_NVIC_SetPriority() HAL_NVIC_Enable</li><li>编写中断服务函数 WWDG_IRQHandler()–&gt;HAL_WWDG_IRQHHandler</li><li>重定义提前唤醒回调函数 HAL_WWDG_EarlyWakeupCallback()</li><li>在窗口器内喂狗 HAN_WWDG_Refresh()</li></ol><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="软件定时（cpu死等）"><a href="#软件定时（cpu死等）" class="headerlink" title="软件定时（cpu死等）"></a>软件定时（cpu死等）</h4><p>时钟频率分之一就是一条指令的时间，使用循环运行空指令__nop()来实现延时。不精准，且造成cpu资源浪费</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stm32 延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span>&#123;</span><br><span class="line">us *= <span class="number">72</span>;</span><br><span class="line">    <span class="keyword">while</span>(us--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定时器原理"><a href="#定时器原理" class="headerlink" title="定时器原理"></a>定时器原理</h4><p>时钟源（精准时钟），经过预分频器，到计数器计数，产生溢出表示时间到了，自动重装载寄存器会把计时器重装载。</p><h4 id="计时器分类"><a href="#计时器分类" class="headerlink" title="计时器分类"></a>计时器分类</h4><ol><li>常规定时器</li></ol><blockquote><p>基本&#x2F;通用&#x2F;高级定时器</p></blockquote><ol start="2"><li>专用定时器</li></ol><blockquote><p>独立看门狗，窗口看门狗，实时时钟TRC，低功耗定时器</p></blockquote><ol start="3"><li>内核定时器</li></ol><blockquote><p>SysTick定时器</p></blockquote><h4 id="定时器特征表"><a href="#定时器特征表" class="headerlink" title="定时器特征表"></a>定时器特征表</h4><p>有八个定时器: 基本TIM6&#x2F;7; 通用TIM2&#x2F;3&#x2F;4&#x2F;5; 高级TIM1&#x2F;8</p><p>F1特征表（芯片不一样要查手册 ）:</p><table><thead><tr><th align="center">类型</th><th align="center">定时器</th><th align="center">位数</th><th align="center">计数模式</th><th align="center">预分频系数</th><th align="center">DMA请求</th><th align="center">捕获&#x2F;比较通道</th><th align="center">互补输出</th></tr></thead><tbody><tr><td align="center">基本</td><td align="center">TIM6&#x2F;7</td><td align="center">16</td><td align="center">递增</td><td align="center">1~65535</td><td align="center">yes</td><td align="center">0</td><td align="center">no</td></tr><tr><td align="center">通用</td><td align="center">TIME2 &#x2F;3&#x2F;4&#x2F;5</td><td align="center">16</td><td align="center">递增&#x2F;递减&#x2F;中央对齐</td><td align="center">1~65535</td><td align="center">yes</td><td align="center">4</td><td align="center">no</td></tr><tr><td align="center">高级</td><td align="center">TIM1&#x2F;8</td><td align="center">16</td><td align="center">递增&#x2F;递减&#x2F;中央对齐</td><td align="center">1~65535</td><td align="center">yes</td><td align="center">4</td><td align="center">yes</td></tr></tbody></table><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th>类型</th><th align="center">主要功能</th></tr></thead><tbody><tr><td>基本</td><td align="center">只有输入输出通道，常用作时基，即定时功能</td></tr><tr><td>通用</td><td align="center">具有多路独立通道，可用于输入捕获&#x2F;输出比较，可以用作时基</td></tr><tr><td>高级</td><td align="center">除既有通用的功能外，还具备带死区控制的互补信号输出，刹车输入等功能（可用于电机控制，数字电源设计等）</td></tr></tbody></table><h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ol><li>TIM6&#x2F;7</li><li>特性：16位递增计时器(0~65535)，16位预分频器(1-65536)，可触发DAC，在更新事件时，可产生中断&#x2F;DMA请求</li></ol><h4 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(RCC) --&gt; B[触发控制器 复位,使能,计数]</span><br><span class="line">B --&gt; |TRGO UI事件| C[DAC]</span><br><span class="line">    B --&gt; D[预分频器]</span><br><span class="line">    D --&gt; E[计数器]</span><br><span class="line">    F[重装载计数器ARR] --&gt; E</span><br><span class="line">    FL[ARPE决定ARR是否具有缓冲] --&gt; F</span><br><span class="line">    E --&gt; G[溢出条件CNT==ARR]</span><br><span class="line">    G --&gt; H[UI事件]</span><br><span class="line">    G --&gt; I[U中断和DMA输出]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="计数模式及溢出条件"><a href="#计数模式及溢出条件" class="headerlink" title="计数模式及溢出条件"></a>计数模式及溢出条件</h4><table><thead><tr><th>计数器模式</th><th>溢出条件</th></tr></thead><tbody><tr><td>递增</td><td>CNT&#x3D;&#x3D;ARR(max)</td></tr><tr><td>递减</td><td>CNT&#x3D;&#x3D;0</td></tr><tr><td>中心对齐</td><td>CNT &#x3D;&#x3D; ARR-1,  CNT &#x3D;&#x3D; 1</td></tr></tbody></table><h4 id="计时器终端相关寄存器"><a href="#计时器终端相关寄存器" class="headerlink" title="计时器终端相关寄存器"></a>计时器终端相关寄存器</h4><blockquote><p>TIMx_CR1</p><p>bit7 ARPE: 自动重装载预装载使能，决定ARR寄存器是否有缓冲</p><p>bit0 CEN: 计数器使能</p></blockquote><blockquote><p>TIMx_DIER</p><p>bit8 UDE: 更新DMA请求使能</p><p>bit0 UIE: 更新中断使能</p></blockquote><blockquote><p>TIMx_SR</p><p>bit0 UIF: 更新中断标志</p></blockquote><blockquote><p>TIMx_CNT</p><p>bit[15:0] 计数器数值</p></blockquote><blockquote><p>TIMx_PSC实际起作用是它的影子寄存器</p><p>bit[15:0] 预分频数值</p></blockquote><blockquote><p>TIMx_ARR    实际起作用是它的影子寄存器</p><p>bit[15:0] 自动重装载数值</p></blockquote><h4 id="寄存器溢出时间计算方法"><a href="#寄存器溢出时间计算方法" class="headerlink" title="寄存器溢出时间计算方法"></a>寄存器溢出时间计算方法</h4><p>$$<br>T_{out}&#x3D;\frac{(ARR+1)*(PSC+1)}{F_t}<br>$$</p><h4 id="定时器中断实验配置步骤"><a href="#定时器中断实验配置步骤" class="headerlink" title="定时器中断实验配置步骤"></a>定时器中断实验配置步骤</h4><ol><li>HAL_TIM_Base_Init()</li><li>HAL_TIM_Base_MspInit(), NVIC, CLOCK etc.</li><li>HAL_TIM_Base_Start_IT()</li><li>HAL_NVIC_SetPriority(), HAL_NVIC_EnableIRQ()</li><li>TIMx_IRQGandler() -&gt; HAL_TIM_IRQHandler()</li></ol><h3 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h3><h4 id="框图-1"><a href="#框图-1" class="headerlink" title="框图"></a>框图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A[时钟源]</span><br><span class="line">B[时钟源:APB 内部触发输入 IO口 定时器的通道1/2]</span><br><span class="line">A --&gt; C[触发控制器 从模式控制器 编码器接口]</span><br><span class="line">C --&gt; |TRGO| D[其他定时器到DAC/ADC]</span><br><span class="line">C --&gt; |复位 使能 递增 计数| E[时基单元 影子寄存器]</span><br><span class="line">E --&gt; |UI U| F[产生事件]</span><br><span class="line">E --&gt; G[捕获/比较公共]</span><br><span class="line">J[外部IO] --&gt; H</span><br><span class="line">H[输入捕获] --&gt; G</span><br><span class="line">G --&gt; |比较中断| I[输出比较]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h4><ol><li>内部时钟(CK_INT),来自APB</li><li>外部时钟模式1:外部输入引脚(TIx),来自定时器通道1或2引脚的信号</li><li>外部时钟模式2:外部触发输入(RTR),来自可以复用为TIMx_ETR的IO引脚</li><li>内如触发输入(ITRx),用于与芯片内部其他通用&#x2F;高级定时器级联</li></ol><table><thead><tr><th>计数器时钟类型选择</th><th>设置方法</th></tr></thead><tbody><tr><td>内部时钟 CK_INT</td><td>set TIMx_SMCR.SMS &#x3D; 000</td></tr><tr><td>外部时钟模式1:外部输入引脚TIx &amp; CH1 CH2</td><td>set TIMx_SMCR.SMS &#x3D; 111</td></tr><tr><td>外部时钟模式2:外部输入引脚ETR</td><td>set TIMx_SMCR.ECE &#x3D; 1</td></tr><tr><td>内部触发输入 ITRx</td><td>参考手册,用于定时器级联</td></tr></tbody></table><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ol><li>TIMx_CR1&#x2F;CR2 控制寄存器</li></ol><blockquote></blockquote><ol start="2"><li>TIMx_SMCR 从模式控制寄存器</li></ol><blockquote><p>b[15] ETP 外部触发极性</p><p>b[14] ECE 外部时钟使能</p><p>b[13:12] ETPS 外部触发预分频</p><p>b[11:8] ETF 外部触发滤波</p><p>b[7] MSM 主&#x2F;从模式</p><p>b[6:4] TS 触发选择</p><p>b[2:0] SMS 从模式选择</p></blockquote><p>略（看手册）</p><h4 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h4><p>使用一个定时器作为另一个定时器的预分频器</p><h4 id="通用定时器中断"><a href="#通用定时器中断" class="headerlink" title="通用定时器中断"></a>通用定时器中断</h4><p>HAL_TIM_Base_Start_IT(); 函数要在TIM_GENERAL_Init函数里，而不是MspInit()函数里</p><p>中断判断： &#x3D;&#x3D; SET 或 !&#x3D; RESET</p><p>if( __HAL_TIM_GET_ITSTATUS(&amp;tim_HandleX, TIM_IT_UPDATE) &#x3D;&#x3D; SET)</p><h4 id="输出比较部分"><a href="#输出比较部分" class="headerlink" title="输出比较部分"></a>输出比较部分</h4><p>PWM原理</p><p>PWM: 脉冲宽度调制</p><p>ARR 决定PWM周期</p><p>CCRX 决定PWM占空比 </p><p>PWM周期&#x2F;频率<br>$$<br>T_{out}&#x3D;\frac{(ARR + 1)*(PSC + 1)}{F_t}<br>$$</p><h4 id="输入捕获部分"><a href="#输入捕获部分" class="headerlink" title="输入捕获部分"></a>输入捕获部分</h4><p>捕获上升&#x2F;下降沿触发，编写逻辑</p><p>查看数据手册，看定时器的输入捕获通道在哪些GPIO端口，启用复用功能或复用重定义功能。</p><h4 id="外部时钟模式"><a href="#外部时钟模式" class="headerlink" title="外部时钟模式"></a>外部时钟模式</h4><p>配置定时器基本配置</p><p>配置从模式</p><h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><h1 id="构建HAL库工程（不使用cubemx）"><a href="#构建HAL库工程（不使用cubemx）" class="headerlink" title="构建HAL库工程（不使用cubemx）"></a>构建HAL库工程（不使用cubemx）</h1><h2 id="必须文件"><a href="#必须文件" class="headerlink" title="必须文件"></a>必须文件</h2><ol><li>stm32f1xx_hal_conf.h通过宏定义来include相应的外设头文件</li><li>stm32f1xx_it.h&#x2F;c 中断相关的代码，weak声明的函数需要重定义</li><li>system_stm32f1xx.c 内核级别的依赖程序，系统内核时钟，总线时钟等</li><li>stm32f1xx_hal_msp.c 板级支持包，MCU相关的硬件初始化操作</li></ol><h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><ol><li>HAL_Init(): 外设 flash 中断优先级 systemtick等</li><li>SystemClock_Config(): 配置倍频和总线频率</li><li>外设初始化</li></ol><h1 id="st-link-烧录程序"><a href="#st-link-烧录程序" class="headerlink" title="st-link 烧录程序"></a>st-link 烧录程序</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><blockquote><p>st-flash reset</p></blockquote><blockquote><p>st-info –probe</p></blockquote><blockquote><p>st-flash read out.bin 0x8000000 0x40000</p></blockquote><blockquote><p>st-flash write xxx.bin 0x8000000</p></blockquote><h1 id="Arm-none-eabi-gcc"><a href="#Arm-none-eabi-gcc" class="headerlink" title="Arm-none-eabi-gcc"></a>Arm-none-eabi-gcc</h1><h2 id="二进制复制"><a href="#二进制复制" class="headerlink" title="二进制复制"></a>二进制复制</h2><p><code>arm-none-eabi-objcopy -O binary xxx.elf xxx.bin</code></p><h1 id="PlatforIO"><a href="#PlatforIO" class="headerlink" title="PlatforIO"></a>PlatforIO</h1><h2 id="openocd权限问题"><a href="#openocd权限问题" class="headerlink" title="openocd权限问题"></a>openocd权限问题</h2><p><code>sudo chown -R papillon:users /dev/stlinkv2_4  </code></p><h1 id="GDB-stlink调试程序"><a href="#GDB-stlink调试程序" class="headerlink" title="GDB stlink调试程序"></a>GDB stlink调试程序</h1><ol><li>arm-none-eabi-as -mthumb  -mcpu&#x3D;cortex-m3 -g xxx.s -o xxx.o        <code>-mthumb (16位指令集)</code></li><li>arm-none-eabi-ld xxx.o -T xxx.ld -o xxx.elf</li><li>先编译程序下载到板子上</li><li>运行<code>st-util</code>命令来打开 gdbserver, 并记住端口号 ${port}</li><li>arm-none-eabi-gdb xx.elf</li><li>target remote *: ${port} </li><li>stepi , next, finish, list , continue ，- (图形界面)，info break, display, bt (查看堆栈),  jump <linenum> 跳转到第几行， x (打印地址的值) 等命令</li></ol><h1 id="串口工具"><a href="#串口工具" class="headerlink" title="串口工具"></a>串口工具</h1><h2 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h2><p><code>sudo minicom -s</code> 配置参数</p><p><code>sudo minicom -D /dev/bus/usb/001/012</code> 连接串口</p><p><code>ctrl_A Z</code>菜单</p><h1 id="ARM-汇编"><a href="#ARM-汇编" class="headerlink" title="ARM 汇编"></a>ARM 汇编</h1><h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote><p>cortex-M 系列使用armv7架构，使用thumb 指令集(T32)</p></blockquote><p>模式: User, FIQ, IRQ, ABT, SVC, UND, MON, HYP</p><ul><li><ol><li>R0-R12通用寄存器，放通用数据，32bit</li></ol></li><li><ol start="2"><li>各个模式R0-R12与User模式是共享的（除了 FIQ的R8-R12), PC, CPSR 是共享的</li></ol></li><li><ol start="3"><li>USER模式没有SPSR<blockquote><p>SP 栈指针，存储栈地址<br>LR 链接寄存器，存储子程序返回地址<br>PC 程序计数器<br>APSR&#x2F;CPSR 应用程序状态寄存器&#x2F;当前程序状态寄存器</p></blockquote></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> ARM coretx-M3 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
